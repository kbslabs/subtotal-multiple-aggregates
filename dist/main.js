/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = flatten\nmodule.exports.from = flattenFrom\nmodule.exports.depth = flattenDepth\nmodule.exports.fromDepth = flattenFromDepth\n\n/**\n * Flatten an array.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flatten (array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFrom(array)\n}\n\n/**\n * Flatten an array-like structure.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flattenFrom (array) {\n  return flattenDown(array, [])\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDepth (array, depth) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFromDepth(array, depth)\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenFromDepth (array, depth) {\n  if (typeof depth !== 'number') {\n    throw new TypeError('Expected the depth to be a number')\n  }\n\n  return flattenDownDepth(array, [], depth)\n}\n\n/**\n * Flatten an array indefinitely.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenDown (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDownDepth (array, result, depth) {\n  depth--\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > -1 && Array.isArray(value)) {\n      flattenDownDepth(value, result, depth)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack:///./node_modules/array-flatten/array-flatten.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! array-flatten */ \"./node_modules/array-flatten/array-flatten.js\");\n/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(array_flatten__WEBPACK_IMPORTED_MODULE_0__);\n\n\nlet hasProp = {}.hasOwnProperty;\nlet callWithJQuery = function(pivotModule) {\n  if (typeof exports === \"object\" && typeof module === \"object\") { // CommonJS\n    return module.exports = pivotModule;\n  } else if (typeof define === \"function\" && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) { // AMD\n    return define([\"jquery\"], pivotModule);\n  } else {\n    // Plain browser env\n    return pivotModule(jQuery);\n  }\n};\n\n  callWithJQuery(function($) {\n    var LOOKER_ROW_TOTAL_KEY, SubtotalPivotDataMulti, SubtotalRenderer, aggregatorTemplates, subtotalAggregatorTemplates, usFmtPct;\n    LOOKER_ROW_TOTAL_KEY = '$$$_row_total_$$$';\n    SubtotalPivotDataMulti = (function() {\n      var processKey;\n\n      class SubtotalPivotDataMulti extends $.pivotUtilities.PivotData {\n        constructor(input, opts) {\n          var i, l, len, name, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n          super(input, opts);\n          this.hasColTotals = (ref = opts.hasColTotals) != null ? ref : true;\n          this.hasRowTotals = this.colAttrs.length ? (ref1 = opts.hasRowTotals) != null ? ref1 : true : true;\n          this.labels = (ref2 = opts.labels) != null ? ref2 : {};\n          // Multiple aggregator hack: Let clients pass in aggregators\n          // (plural) and use the first one as the main value for each cell.\n          this.aggregatorNames = (ref3 = opts.aggregatorNames) != null ? ref3 : ['Count'];\n          this.aggregators = (ref4 = opts.aggregators) != null ? ref4 : (function() {\n            var l, len, ref5, results;\n            ref5 = this.aggregatorNames;\n            results = [];\n            for (l = 0, len = ref5.length; l < len; l++) {\n              name = ref5[l];\n              results.push($.pivotUtilities.aggregators[name]({}));\n            }\n            return results;\n          }).call(this);\n          this.aggregatorName = this.aggregatorNames[0];\n          this.aggregator = this.aggregators[0];\n          if (this.aggregatorNames.length !== this.aggregators.length) {\n            throw new Error('aggregators and aggregatorNames must be the same length');\n          }\n          this.allTotal = {};\n          ref5 = this.aggregatorNames;\n          for (i = l = 0, len = ref5.length; l < len; i = ++l) {\n            name = ref5[i];\n            this.allTotal[name] = this.aggregators[i](this, [], []);\n          }\n          SubtotalPivotDataMulti.forEachRecord(this.input, this.derivedAttributes, (record) => {\n            if (this.filter(record)) {\n              return this.processRecord(record);\n            }\n          });\n          this.hasLookerRowTotals = array_flatten__WEBPACK_IMPORTED_MODULE_0___default()(this.getColKeys()).includes(LOOKER_ROW_TOTAL_KEY);\n          this.useLookerRowTotals = ((ref6 = opts.useLookerRowTotals) != null ? ref6 : true) && this.hasLookerRowTotals;\n        }\n\n        processRecord(record) { //this code is called in a tight loop\n          var addKey, aggregator, attr, base, base1, colKey, fColKey, fRowKey, flatColKey, flatKey, flatRowKey, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, name, o, q, r, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rowKey, s, t, u, w, y, z;\n          \n          // Since this gets called in the PivotData (superclass) constructor\n          // but we haven't yet initialized @aggregators, don't do anything.\n          if (!this.aggregators) {\n            return;\n          }\n          rowKey = [];\n          addKey = false;\n          ref = this.rowAttrs;\n          for (l = 0, len = ref.length; l < len; l++) {\n            attr = ref[l];\n            rowKey.push((ref1 = record[attr]) != null ? ref1 : \"null\");\n            flatKey = rowKey.join(String.fromCharCode(0));\n            if (!this.rowTotals[flatKey]) {\n              this.rowTotals[flatKey] = {};\n              ref2 = this.aggregatorNames;\n              for (i = o = 0, len1 = ref2.length; o < len1; i = ++o) {\n                name = ref2[i];\n                aggregator = this.aggregators[i];\n                this.rowTotals[flatKey][name] = aggregator(this, rowKey.slice(), []);\n                addKey = true;\n              }\n            }\n            if (this.colAttrs.length && record[this.colAttrs[0]] === LOOKER_ROW_TOTAL_KEY) {\n              // Don't aggregate alread-aggregated data.\n              continue;\n            }\n            ref3 = this.aggregatorNames;\n            for (q = 0, len2 = ref3.length; q < len2; q++) {\n              name = ref3[q];\n              this.rowTotals[flatKey][name].push(record);\n            }\n          }\n          if (addKey) {\n            this.rowKeys.push(rowKey);\n          }\n          colKey = [];\n          addKey = false;\n          ref4 = this.colAttrs;\n          for (r = 0, len3 = ref4.length; r < len3; r++) {\n            attr = ref4[r];\n            colKey.push((ref5 = record[attr]) != null ? ref5 : \"null\");\n            flatKey = colKey.join(String.fromCharCode(0));\n            if (!this.colTotals[flatKey]) {\n              this.colTotals[flatKey] = {};\n              ref6 = this.aggregatorNames;\n              for (i = s = 0, len4 = ref6.length; s < len4; i = ++s) {\n                name = ref6[i];\n                aggregator = this.aggregators[i];\n                this.colTotals[flatKey][name] = aggregator(this, [], colKey.slice());\n                addKey = true;\n              }\n            }\n            ref7 = this.aggregatorNames;\n            for (t = 0, len5 = ref7.length; t < len5; t++) {\n              name = ref7[t];\n              this.colTotals[flatKey][name].push(record);\n            }\n          }\n          if (addKey) {\n            this.colKeys.push(colKey);\n          }\n          if (colKey[0] !== LOOKER_ROW_TOTAL_KEY) {\n            ref8 = this.aggregatorNames;\n            for (u = 0, len6 = ref8.length; u < len6; u++) {\n              name = ref8[u];\n              this.allTotal[name].push(record);\n            }\n          }\n          m = rowKey.length - 1;\n          n = colKey.length - 1;\n          if (m < 0 || n < 0) {\n            return;\n          }\n          for (i = w = 0, ref9 = m; (0 <= ref9 ? w <= ref9 : w >= ref9); i = 0 <= ref9 ? ++w : --w) {\n            fRowKey = rowKey.slice(0, i + 1);\n            flatRowKey = fRowKey.join(String.fromCharCode(0));\n            if ((base = this.tree)[flatRowKey] == null) {\n              base[flatRowKey] = {};\n            }\n            for (j = y = 0, ref10 = n; (0 <= ref10 ? y <= ref10 : y >= ref10); j = 0 <= ref10 ? ++y : --y) {\n              fColKey = colKey.slice(0, j + 1);\n              flatColKey = fColKey.join(String.fromCharCode(0));\n              if ((base1 = this.tree[flatRowKey])[flatColKey] == null) {\n                base1[flatColKey] = {};\n              }\n              ref11 = this.aggregatorNames;\n              for (k = z = 0, len7 = ref11.length; z < len7; k = ++z) {\n                name = ref11[k];\n                aggregator = this.aggregators[k];\n                if (!this.tree[flatRowKey][flatColKey][name]) {\n                  this.tree[flatRowKey][flatColKey][name] = aggregator(this, fRowKey, fColKey);\n                }\n                this.tree[flatRowKey][flatColKey][name].push(record);\n              }\n            }\n          }\n        }\n\n      };\n\n      processKey = function(record, totals, keys, attrs, getAggregator) {\n        var addKey, attr, flatKey, key, l, len, ref;\n        key = [];\n        addKey = false;\n        for (l = 0, len = attrs.length; l < len; l++) {\n          attr = attrs[l];\n          key.push((ref = record[attr]) != null ? ref : \"null\");\n          flatKey = key.join(String.fromCharCode(0));\n          if (!totals[flatKey]) {\n            totals[flatKey] = getAggregator(key.slice());\n            addKey = true;\n          }\n          totals[flatKey].push(record);\n        }\n        if (addKey) {\n          keys.push(key);\n        }\n        return key;\n      };\n\n      return SubtotalPivotDataMulti;\n\n    }).call(this);\n    $.pivotUtilities.SubtotalPivotDataMulti = SubtotalPivotDataMulti;\n    SubtotalRenderer = function(pivotData, opts) {\n      var addClass, adjustAxisHeader, aggregatorNames, aggregators, allTotal, arrowCollapsed, arrowExpanded, buildAxisHeader, buildColAxisHeaders, buildColHeader, buildColTotals, buildColTotalsHeader, buildGrandTotal, buildRowAxisHeaders, buildRowHeader, buildRowTotalsHeader, buildValues, classColCollapsed, classColExpanded, classColHide, classColShow, classCollapsed, classExpanded, classRowCollapsed, classRowExpanded, classRowHide, classRowShow, clickStatusCollapsed, clickStatusExpanded, colAttrs, colKeys, colTotals, collapseAxis, collapseAxisHeaders, collapseChildCol, collapseChildRow, collapseCol, collapseHiddenColSubtotal, collapseRow, collapseShowColSubtotal, collapseShowRowSubtotal, createElement, defaults, escapeHtml, expandAxis, expandChildCol, expandChildRow, expandCol, expandHideColSubtotal, expandHideRowSubtotal, expandRow, expandShowColSubtotal, expandShowRowSubtotal, getHeaderText, getTableEventHandlers, hasClass, hasColTotals, hasLookerRowTotals, hasRowTotals, hideChildCol, hideChildRow, labels, lastPivotHeader, main, parseLabel, processKeys, removeClass, replaceClass, rowAttrs, rowKeys, rowTotals, setAttributes, showChildCol, showChildRow, tree, useLookerRowTotals;\n      defaults = {\n        table: {\n          clickCallback: null\n        },\n        localeStrings: {\n          totals: \"Totals\",\n          subtotalOf: \"Subtotal of\"\n        },\n        arrowCollapsed: \"\\u25B6\",\n        arrowExpanded: \"\\u25E2\",\n        rowSubtotalDisplay: {\n          displayOnTop: true,\n          disableFrom: 99999,\n          collapseAt: 1,\n          hideOnExpand: false,\n          disableExpandCollapse: false\n        },\n        colSubtotalDisplay: {\n          displayOnTop: true,\n          disableFrom: 0,\n          collapseAt: 0,\n          hideOnExpand: false,\n          disableExpandCollapse: false\n        }\n      };\n      opts = $.extend(true, {}, defaults, opts);\n      if (opts.rowSubtotalDisplay.disableSubtotal) {\n        opts.rowSubtotalDisplay.disableFrom = 0;\n      }\n      if (typeof opts.rowSubtotalDisplay.disableAfter !== 'undefined' && opts.rowSubtotalDisplay.disableAfter !== null) {\n        opts.rowSubtotalDisplay.disableFrom = opts.rowSubtotalDisplay.disableAfter + 1;\n      }\n      if (typeof opts.rowSubtotalDisplay.collapseAt !== 'undefined' && opts.collapseRowsAt !== null) {\n        opts.rowSubtotalDisplay.collapseAt = 2;\n      }\n      if (opts.colSubtotalDisplay.disableSubtotal) {\n        opts.colSubtotalDisplay.disableFrom = 0;\n      }\n      if (typeof opts.colSubtotalDisplay.disableAfter !== 'undefined' && opts.colSubtotalDisplay.disableAfter !== null) {\n        opts.colSubtotalDisplay.disableFrom = opts.colSubtotalDisplay.disableAfter + 1;\n      }\n      if (typeof opts.colSubtotalDisplay.collapseAt !== 'undefined' && opts.collapseColsAt !== null) {\n        opts.colSubtotalDisplay.collapseAt = opts.collapseColsAt;\n      }\n      if (opts.colSubtotalDisplay.disableFrom > 0) {\n        throw new Error('Column subtotals are unimplemented');\n      }\n      colAttrs = pivotData.colAttrs;\n      rowAttrs = pivotData.rowAttrs;\n      rowKeys = pivotData.getRowKeys();\n      colKeys = pivotData.getColKeys();\n      tree = pivotData.tree;\n      rowTotals = pivotData.rowTotals;\n      colTotals = pivotData.colTotals;\n      allTotal = pivotData.allTotal;\n      aggregators = pivotData.aggregators;\n      aggregatorNames = pivotData.aggregatorNames;\n      hasColTotals = pivotData.hasColTotals;\n      hasRowTotals = pivotData.hasRowTotals;\n      labels = pivotData.labels;\n      hasLookerRowTotals = pivotData.hasLookerRowTotals;\n      useLookerRowTotals = pivotData.useLookerRowTotals;\n      classRowHide = \"rowhide\";\n      classRowShow = \"rowshow\";\n      classColHide = \"colhide\";\n      classColShow = \"colshow\";\n      clickStatusExpanded = \"expanded\";\n      clickStatusCollapsed = \"collapsed\";\n      classExpanded = \"expanded\";\n      classCollapsed = \"collapsed\";\n      classRowExpanded = \"rowexpanded\";\n      classRowCollapsed = \"rowcollapsed\";\n      classColExpanded = \"colexpanded\";\n      classColCollapsed = \"colcollapsed\";\n      arrowExpanded = opts.arrowExpanded;\n      arrowCollapsed = opts.arrowCollapsed;\n      // Based on http://stackoverflow.com/questions/195951/change-an-elements-class-with-javascript -- Begin\n      hasClass = function(element, className) {\n        var regExp;\n        regExp = new RegExp(\"(?:^|\\\\s)\" + className + \"(?!\\\\S)\", \"g\");\n        return element.className.match(regExp) !== null;\n      };\n      removeClass = function(element, className) {\n        var l, len, name, ref, regExp, results;\n        ref = className.split(\" \");\n        results = [];\n        for (l = 0, len = ref.length; l < len; l++) {\n          name = ref[l];\n          regExp = new RegExp(\"(?:^|\\\\s)\" + name + \"(?!\\\\S)\", \"g\");\n          results.push(element.className = element.className.replace(regExp, ''));\n        }\n        return results;\n      };\n      addClass = function(element, className) {\n        var l, len, name, ref, results;\n        ref = className.split(\" \");\n        results = [];\n        for (l = 0, len = ref.length; l < len; l++) {\n          name = ref[l];\n          if (!hasClass(element, name)) {\n            results.push(element.className += \" \" + name);\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      };\n      replaceClass = function(element, replaceClassName, byClassName) {\n        removeClass(element, replaceClassName);\n        return addClass(element, byClassName);\n      };\n      // Based on http://stackoverflow.com/questions/195951/change-an-elements-class-with-javascript -- End\n      escapeHtml = function(unsafe) {\n        return unsafe.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n      };\n      parseLabel = function(parts) {\n        var append, out;\n        // Safe way to insert stylized labels. Parts can be a string or object { label, subabel }, or array as such.\n        out = '';\n        append = function(value) {\n          var l, len, results, x;\n          if (Array.isArray(value)) {\n            results = [];\n            for (l = 0, len = value.length; l < len; l++) {\n              x = value[l];\n              results.push(append(x));\n            }\n            return results;\n          } else if (value != null ? value.label : void 0) {\n            out += escapeHtml(value.label);\n            if (value.sublabel) {\n              return out += ` <em>${escapeHtml(value.sublabel)}</em>`;\n            }\n          } else if (value !== null && value !== void 0) {\n            return out += escapeHtml(String(value));\n          }\n        };\n        append(parts);\n        return out;\n      };\n      createElement = function(elementType, className, label, attributes, eventHandlers) {\n        var attr, e, event, handler, val;\n        e = document.createElement(elementType);\n        if (className != null) {\n          e.className = className;\n        }\n        e.innerHTML = parseLabel(label);\n        if (attributes != null) {\n          for (attr in attributes) {\n            if (!hasProp.call(attributes, attr)) continue;\n            val = attributes[attr];\n            e.setAttribute(attr, val);\n          }\n        }\n        if (eventHandlers != null) {\n          for (event in eventHandlers) {\n            if (!hasProp.call(eventHandlers, event)) continue;\n            handler = eventHandlers[event];\n            e.addEventListener(event, handler);\n          }\n        }\n        return e;\n      };\n      setAttributes = function(e, attrs) {\n        var a, results, v;\n        results = [];\n        for (a in attrs) {\n          if (!hasProp.call(attrs, a)) continue;\n          v = attrs[a];\n          results.push(e.setAttribute(a, v));\n        }\n        return results;\n      };\n      processKeys = function(keysArr, className, opts) {\n        var headers, lastIdx, row;\n        lastIdx = keysArr[0].length - 1;\n        headers = {\n          children: []\n        };\n        row = 0;\n        keysArr.reduce((val0, k0) => {\n          var col;\n          col = 0;\n          k0.reduce((acc, curVal, curIdx, arr) => {\n            var i, key, l, node, ref;\n            if (!acc[curVal]) {\n              key = k0.slice(0, col + 1);\n              acc[curVal] = {\n                row: row,\n                col: col,\n                descendants: 0,\n                children: [],\n                text: curVal,\n                key: key,\n                flatKey: key.join(String.fromCharCode(0)),\n                firstLeaf: null,\n                leaves: 0,\n                parent: col !== 0 ? acc : null,\n                th: createElement(\"th\", className, curVal),\n                childrenSpan: 0\n              };\n              acc.children.push(curVal);\n            }\n            if (col > 0) {\n              acc.descendants++;\n            }\n            col++;\n            if (curIdx === lastIdx) {\n              node = headers;\n              for (i = l = 0, ref = lastIdx - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {\n                if (!(lastIdx > 0)) {\n                  continue;\n                }\n                node[k0[i]].leaves++;\n                if (!node[k0[i]].firstLeaf) {\n                  node[k0[i]].firstLeaf = acc[curVal];\n                }\n                node = node[k0[i]];\n              }\n              return headers;\n            }\n            return acc[curVal];\n          }, headers);\n          row++;\n          return headers;\n        }, headers);\n        return headers;\n      };\n      buildAxisHeader = function(axisHeaders, col, attrs, opts) {\n        var ah, arrow, hClass, ref;\n        ah = {\n          text: (ref = labels[attrs[col]]) != null ? ref : attrs[col],\n          expandedCount: 0,\n          expandables: 0,\n          attrHeaders: [],\n          clickStatus: clickStatusExpanded,\n          onClick: collapseAxis\n        };\n        arrow = `${arrowExpanded} `;\n        hClass = classExpanded;\n        if (col >= opts.collapseAt) {\n          arrow = `${arrowCollapsed} `;\n          hClass = classCollapsed;\n          ah.clickStatus = clickStatusCollapsed;\n          ah.onClick = expandAxis;\n        }\n        if (col === attrs.length - 1 || col >= opts.disableFrom || opts.disableExpandCollapse) {\n          arrow = \"\";\n        }\n        ah.th = createElement(\"th\", `pvtAxisLabel ${hClass}`, [arrow, ah.text]);\n        if (col < attrs.length - 1 && col < opts.disableFrom && !opts.disableExpandCollapse) {\n          ah.th.onclick = function(event) {\n            event = event || window.event;\n            return ah.onClick(axisHeaders, col, attrs, opts);\n          };\n        }\n        axisHeaders.ah.push(ah);\n        return ah;\n      };\n      buildColAxisHeaders = function(thead, rowAttrs, colAttrs, opts) {\n        var ah, attr, axisHeaders, col, l, len;\n        axisHeaders = {\n          collapseAttrHeader: collapseCol,\n          expandAttrHeader: expandCol,\n          ah: []\n        };\n        for (col = l = 0, len = colAttrs.length; l < len; col = ++l) {\n          attr = colAttrs[col];\n          ah = buildAxisHeader(axisHeaders, col, colAttrs, opts.colSubtotalDisplay);\n          ah.th.colSpan = rowAttrs.length;\n          ah.tr = createElement(\"tr\", \"pvtColAxisHeaders\");\n          ah.tr.appendChild(ah.th);\n          thead.appendChild(ah.tr);\n        }\n        return axisHeaders;\n      };\n      buildRowAxisHeaders = function(thead, rowAttrs, colAttrs, opts) {\n        var ah, axisHeaders, col, l, ref;\n        axisHeaders = {\n          collapseAttrHeader: collapseRow,\n          expandAttrHeader: expandRow,\n          ah: [],\n          tr: createElement(\"tr\", \"pvtRowAxisHeaders\")\n        };\n        for (col = l = 0, ref = rowAttrs.length - 1; (0 <= ref ? l <= ref : l >= ref); col = 0 <= ref ? ++l : --l) {\n          ah = buildAxisHeader(axisHeaders, col, rowAttrs, opts.rowSubtotalDisplay);\n          axisHeaders.tr.appendChild(ah.th);\n        }\n        thead.appendChild(axisHeaders.tr);\n        return axisHeaders;\n      };\n      getHeaderText = function(h, attrs, opts) {\n        var arrow, label;\n        arrow = ` ${arrowExpanded} `;\n        if (h.col === attrs.length - 1 || h.col >= opts.disableFrom || opts.disableExpandCollapse || h.children.length === 0) {\n          arrow = \"\";\n        }\n        label = h.text === LOOKER_ROW_TOTAL_KEY ? 'Total' : h.text;\n        return `${arrow}${label}`;\n      };\n      buildColHeader = function(axisHeaders, attrHeaders, h, rowAttrs, colAttrs, node, opts) {\n        var ah, chKey, l, len, ref, ref1;\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          // DF Recurse\n          buildColHeader(axisHeaders, attrHeaders, h[chKey], rowAttrs, colAttrs, node, opts);\n        }\n        // Process\n        ah = axisHeaders.ah[h.col];\n        ah.attrHeaders.push(h);\n        h.node = node.counter;\n        h.onClick = collapseCol;\n        addClass(h.th, `${classColShow} col${h.row} colcol${h.col} ${classColExpanded}`);\n        h.th.setAttribute(\"data-colnode\", h.node);\n        h.th.colSpan = h.children.length ? h.childrenSpan : aggregatorNames.length;\n        //h.th.rowSpan = 2 if h.children.length is 0 and rowAttrs.length isnt 0\n        h.th.innerHTML = getHeaderText(h, colAttrs, opts.colSubtotalDisplay);\n        if (h.children.length !== 0 && h.col < opts.colSubtotalDisplay.disableFrom) {\n          ah.expandables++;\n          ah.expandedCount += 1;\n          if (!opts.colSubtotalDisplay.hideOnExpand) {\n            h.th.colSpan++;\n          }\n          if (!opts.colSubtotalDisplay.disableExpandCollapse) {\n            h.th.onclick = function(event) {\n              event = event || window.event;\n              return h.onClick(axisHeaders, h, opts.colSubtotalDisplay);\n            };\n          }\n          h.sTh = createElement(\"th\", `pvtColLabelFiller ${classColShow} col${h.row} colcol${h.col} ${classColExpanded}`);\n          h.sTh.setAttribute(\"data-colnode\", h.node);\n          if (opts.colSubtotalDisplay.hideOnExpand) {\n            // h.sTh.rowSpan = colAttrs.length-h.col\n            replaceClass(h.sTh, classColShow, classColHide);\n          }\n          h[h.children[0]].tr.appendChild(h.sTh);\n        }\n        if ((ref1 = h.parent) != null) {\n          ref1.childrenSpan += h.th.colSpan;\n        }\n        h.clickStatus = clickStatusExpanded;\n        if (h.text === LOOKER_ROW_TOTAL_KEY) {\n          if (!h.children.length) {\n            //h.th.rowSpan = colAttrs.length\n            addClass(h.th, \"pvtColTotal\");\n            ah.tr.appendChild(h.th);\n            h.tr = ah.tr;\n          } else {\n            ah.tr.appendChild(createElement(\"th\", null, null, {\n              colspan: aggregatorNames.length\n            }));\n          }\n        } else {\n          ah.tr.appendChild(h.th);\n          h.tr = ah.tr;\n        }\n        attrHeaders.push(h);\n        return node.counter++;\n      };\n      buildRowTotalsHeader = function(tr, colKeyHeaders, rowAttrs, colAttrs) {\n        var addHeaders, child, l, len, len1, len2, len3, name, o, q, r, ref, th;\n        if (colAttrs.length > 0) {\n          // We have pivots.\n          if (colKeyHeaders) {\n            addHeaders = function(headers) {\n              var child, l, len, len1, name, o, ref, results, results1, th;\n              if (headers.children.length > 0) {\n                ref = headers.children;\n                results = [];\n                for (l = 0, len = ref.length; l < len; l++) {\n                  child = ref[l];\n                  if (child === LOOKER_ROW_TOTAL_KEY) {\n                    continue;\n                  }\n                  results.push(addHeaders(headers[child]));\n                }\n                return results;\n              } else {\n                results1 = [];\n                for (o = 0, len1 = aggregatorNames.length; o < len1; o++) {\n                  name = aggregatorNames[o];\n                  th = createElement(\"th\", \"rowTotal\", labels[name]);\n                  results1.push(tr.appendChild(th));\n                }\n                return results1;\n              }\n            };\n            addHeaders(colKeyHeaders);\n            if (useLookerRowTotals) {\n              ref = colKeyHeaders.children;\n              for (l = 0, len = ref.length; l < len; l++) {\n                child = ref[l];\n                if (child === LOOKER_ROW_TOTAL_KEY) {\n                  continue;\n                }\n                for (o = 0, len1 = aggregatorNames.length; o < len1; o++) {\n                  name = aggregatorNames[o];\n                  th = createElement(\"th\", \"rowTotal\", labels[name]);\n                  tr.appendChild(th);\n                }\n              }\n            }\n            if (hasRowTotals && !useLookerRowTotals) {\n              for (q = 0, len2 = aggregatorNames.length; q < len2; q++) {\n                name = aggregatorNames[q];\n                th = createElement(\"th\", \"rowTotal\", labels[name]);\n                tr.appendChild(th);\n              }\n            }\n          } else {\n            th = createElement(\"th\", \"pvtColLabel pvtColTotal\", 'Total*', {\n              colspan: aggregatorNames.length\n            });\n            tr.appendChild(th);\n          }\n        } else {\n// No pivots, but we still need to add column headers.\n          for (r = 0, len3 = aggregatorNames.length; r < len3; r++) {\n            name = aggregatorNames[r];\n            th = createElement(\"th\", \"rowTotal\", labels[name]);\n            tr.appendChild(th);\n          }\n        }\n      };\n      lastPivotHeader = null;\n      buildRowHeader = function(tbody, axisHeaders, attrHeaders, h, rowAttrs, colAttrs, node, opts) {\n        var ah, chKey, firstChild, i, l, len, o, ref, ref1, ref2;\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          // DF Recurse\n          buildRowHeader(tbody, axisHeaders, attrHeaders, h[chKey], rowAttrs, colAttrs, node, opts);\n        }\n        // Process\n        ah = axisHeaders.ah[h.col];\n        ah.attrHeaders.push(h);\n        h.node = node.counter;\n        h.onClick = collapseRow;\n        if (h.children.length !== 0) {\n          firstChild = h[h.children[0]];\n        }\n        if (lastPivotHeader) {\n          removeClass(lastPivotHeader, \"lastPivot\");\n        }\n        lastPivotHeader = h.th;\n        addClass(h.th, `${classRowShow} pvtRowHeader lastPivot row${h.row} rowcol${h.col} ${classRowExpanded}`);\n        h.th.setAttribute(\"data-rownode\", h.node);\n        if (h.children.length !== 0) {\n          // h.th.colSpan = 2 if h.col is rowAttrs.length-1 and colAttrs.length isnt 0\n          h.th.rowSpan = h.childrenSpan;\n        }\n        h.th.innerHTML = getHeaderText(h, rowAttrs, opts.rowSubtotalDisplay);\n        h.tr = createElement(\"tr\", `row${h.row}`);\n        h.tr.appendChild(h.th);\n        if (h.children.length === 0) {\n          tbody.appendChild(h.tr);\n        } else {\n          tbody.insertBefore(h.tr, firstChild.tr);\n        }\n        if (h.children.length !== 0 && h.col < opts.rowSubtotalDisplay.disableFrom) {\n          ++ah.expandedCount;\n          ++ah.expandables;\n          if (!opts.rowSubtotalDisplay.disableExpandCollapse) {\n            h.th.onclick = function(event) {\n              event = event || window.event;\n              return h.onClick(axisHeaders, h, opts.rowSubtotalDisplay);\n            };\n          }\n          for (i = o = 0, ref1 = rowAttrs.length - h.col - 1; (0 <= ref1 ? o < ref1 : o > ref1); i = 0 <= ref1 ? ++o : --o) {\n            h.sTh = createElement(\"th\", `pvtRowLabelFiller row${h.row} rowcol${h.col} ${classRowExpanded} ${classRowShow}`);\n            if (opts.rowSubtotalDisplay.hideOnExpand) {\n              replaceClass(h.sTh, classRowShow, classRowHide);\n            }\n            h.sTh.setAttribute(\"data-rownode\", h.node);\n            //h.sTh.colSpan = rowAttrs.length-h.col-1\n            if (opts.rowSubtotalDisplay.displayOnTop) {\n              h.tr.appendChild(h.sTh);\n            } else {\n              h.th.rowSpan += 1; // if not opts.rowSubtotalDisplay.hideOnExpand\n              h.sTr = createElement(\"tr\", `row${h.row}`);\n              h.sTr.appendChild(h.sTh);\n              tbody.appendChild(h.sTr);\n            }\n          }\n        }\n        if (h.children.length !== 0) {\n          h.th.rowSpan++;\n        }\n        if ((ref2 = h.parent) != null) {\n          ref2.childrenSpan += h.th.rowSpan;\n        }\n        h.clickStatus = clickStatusExpanded;\n        attrHeaders.push(h);\n        return node.counter++;\n      };\n      getTableEventHandlers = function(value, rowKey, colKey, rowAttrs, colAttrs, opts) {\n        var attr, event, eventHandlers, filters, handler, i, ref, ref1;\n        if (!((ref = opts.table) != null ? ref.eventHandlers : void 0)) {\n          return;\n        }\n        eventHandlers = {};\n        ref1 = opts.table.eventHandlers;\n        for (event in ref1) {\n          if (!hasProp.call(ref1, event)) continue;\n          handler = ref1[event];\n          filters = {};\n          for (i in colAttrs) {\n            if (!hasProp.call(colAttrs, i)) continue;\n            attr = colAttrs[i];\n            if (colKey[i] != null) {\n              filters[attr] = colKey[i];\n            }\n          }\n          for (i in rowAttrs) {\n            if (!hasProp.call(rowAttrs, i)) continue;\n            attr = rowAttrs[i];\n            if (rowKey[i] != null) {\n              filters[attr] = rowKey[i];\n            }\n          }\n          eventHandlers[event] = function(e) {\n            return handler(e, value, filters, pivotData);\n          };\n        }\n        return eventHandlers;\n      };\n      buildValues = function(tbody, colAttrHeaders, rowAttrHeaders, rowAttrs, colAttrs, opts) {\n        var aggregator, ch, cls, l, len, len1, len2, len3, name, o, q, r, rCls, ref, rh, td, totalAggregator, tr, val;\n        for (l = 0, len = rowAttrHeaders.length; l < len; l++) {\n          rh = rowAttrHeaders[l];\n          if (!(rh.col === rowAttrs.length - 1 || (rh.children.length !== 0 && rh.col < opts.rowSubtotalDisplay.disableFrom))) {\n            continue;\n          }\n          rCls = `pvtVal row${rh.row} rowcol${rh.col} ${classRowExpanded}`;\n          if (rh.children.length > 0) {\n            rCls += \" pvtRowSubtotal\";\n            rCls += opts.rowSubtotalDisplay.hideOnExpand ? ` ${classRowHide}` : `  ${classRowShow}`;\n          } else {\n            rCls += ` ${classRowShow}`;\n          }\n          tr = rh.sTr ? rh.sTr : rh.tr;\n          for (o = 0, len1 = colAttrHeaders.length; o < len1; o++) {\n            ch = colAttrHeaders[o];\n            if (ch.col === colAttrs.length - 1 || (ch.children.length !== 0 && ch.col < opts.colSubtotalDisplay.disableFrom)) {\n              for (q = 0, len2 = aggregatorNames.length; q < len2; q++) {\n                name = aggregatorNames[q];\n                let reference = tree[rh.flatKey][ch.flatKey] && tree[rh.flatKey][ch.flatKey][name];\n                aggregator = reference ? reference : {\n                  value: (function() {\n                    return null;\n                  }),\n                  format: function() {\n                    return \"\";\n                  }\n                };\n                val = aggregator.value();\n                cls = ` ${rCls} col${ch.row} colcol${ch.col} ${classColExpanded}`;\n                if (ch.children.length > 1) {\n                  cls += \" pvtColSubtotal\";\n                  cls += opts.colSubtotalDisplay.hideOnExpand ? ` ${classColHide}` : ` ${classColShow}`;\n                } else {\n                  cls += ` ${classColShow}`;\n                }\n                td = createElement(\"td\", cls, aggregator.format(val), {\n                  \"data-value\": val,\n                  \"data-rownode\": rh.node,\n                  \"data-colnode\": ch.node\n                }, getTableEventHandlers(val, rh.key, ch.key, rowAttrs, colAttrs, opts));\n                tr.appendChild(td);\n              }\n            }\n          }\n          // buildRowTotal\n          if (hasRowTotals && !useLookerRowTotals) {\n            for (r = 0, len3 = aggregatorNames.length; r < len3; r++) {\n              name = aggregatorNames[r];\n              totalAggregator = rowTotals[rh.flatKey][name];\n              val = totalAggregator.value();\n              td = createElement(\"td\", `pvtTotal rowTotal ${rCls}`, totalAggregator.format(val), {\n                \"data-value\": val,\n                \"data-row\": `row${rh.row}`,\n                \"data-rowcol\": `col${rh.col}`,\n                \"data-rownode\": rh.node\n              });\n              getTableEventHandlers(val, rh.key, [], rowAttrs, colAttrs, opts);\n              tr.appendChild(td);\n            }\n          }\n        }\n      };\n      buildColTotalsHeader = function(rowAttrs, colAttrs) {\n        var colspan, th, tr;\n        tr = createElement(\"tr\", \"pvtRowTotal\");\n        colspan = rowAttrs.length;\n        th = createElement(\"th\", \"pvtTotalLabel colTotal\", opts.localeStrings.totals, {\n          colspan: colspan\n        });\n        tr.appendChild(th);\n        return tr;\n      };\n      buildColTotals = function(tr, attrHeaders, rowAttrs, colAttrs, opts) {\n        var clsNames, h, i, l, len, len1, name, o, td, totalAggregator, val;\n        for (l = 0, len = attrHeaders.length; l < len; l++) {\n          h = attrHeaders[l];\n          if (!(h.col === colAttrs.length - 1 || (h.children.length !== 0 && h.col < opts.colSubtotalDisplay.disableFrom))) {\n            continue;\n          }\n          clsNames = `pvtVal pvtTotal colTotal ${classColExpanded} col${h.row} colcol${h.col}`;\n          if (h.children.length !== 0) {\n            clsNames += \" pvtColSubtotal\";\n            clsNames += opts.colSubtotalDisplay.hideOnExpand ? ` ${classColHide}` : ` ${classColShow}`;\n          } else {\n            clsNames += ` ${classColShow}`;\n          }\n          for (i = o = 0, len1 = aggregatorNames.length; o < len1; i = ++o) {\n            name = aggregatorNames[i];\n            totalAggregator = colTotals[h.flatKey][aggregatorNames[i]];\n            val = totalAggregator.value();\n            td = createElement(\"td\", clsNames, totalAggregator.format(val), {\n              \"data-value\": val,\n              \"data-for\": `col${h.col}`,\n              \"data-colnode\": `${h.node}`\n            }, getTableEventHandlers(val, [], h.key, rowAttrs, colAttrs, opts));\n            tr.appendChild(td);\n          }\n        }\n      };\n      buildGrandTotal = function(tbody, tr, rowAttrs, colAttrs, opts) {\n        var l, len, name, results, td, totalAggregator, val;\n        results = [];\n        for (l = 0, len = aggregatorNames.length; l < len; l++) {\n          name = aggregatorNames[l];\n          totalAggregator = allTotal[name];\n          val = totalAggregator.value();\n          td = createElement(\"td\", \"pvtGrandTotal\", totalAggregator.format(val), {\n            \"data-value\": val\n          }, getTableEventHandlers(val, [], [], rowAttrs, colAttrs, opts));\n          results.push(tr.appendChild(td));\n        }\n        return results;\n      };\n      collapseAxisHeaders = function(axisHeaders, col, opts) {\n        var ah, collapsible, i, l, ref, ref1, results;\n        collapsible = Math.min(axisHeaders.ah.length - 2, opts.disableFrom - 1);\n        if (col > collapsible) {\n          return;\n        }\n        results = [];\n        for (i = l = ref = col, ref1 = collapsible; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {\n          ah = axisHeaders.ah[i];\n          replaceClass(ah.th, classExpanded, classCollapsed);\n          ah.th.innerHTML = parseLabel([` ${arrowCollapsed} `, ah.text]);\n          ah.clickStatus = clickStatusCollapsed;\n          results.push(ah.onClick = expandAxis);\n        }\n        return results;\n      };\n      adjustAxisHeader = function(axisHeaders, col, opts) {\n        var ah;\n        ah = axisHeaders.ah[col];\n        if (ah.expandedCount === 0) {\n          return collapseAxisHeaders(axisHeaders, col, opts);\n        } else if (ah.expandedCount === ah.expandables) {\n          replaceClass(ah.th, classCollapsed, classExpanded);\n          ah.th.innerHTML = parseLabel([` ${arrowExpanded} `, ah.text]);\n          ah.clickStatus = clickStatusExpanded;\n          return ah.onClick = collapseAxis;\n        }\n      };\n      hideChildCol = function(ch) {\n        return $(ch.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${ch.node}\\\"], th[data-colnode=\\\"${ch.node}\\\"]`).removeClass(classColShow).addClass(classColHide);\n      };\n      collapseHiddenColSubtotal = function(h, opts) {\n        $(h.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`).removeClass(classColExpanded).addClass(classColCollapsed);\n        if (h.children.length !== 0) {\n          h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n        }\n        return h.th.colSpan = 1;\n      };\n      collapseShowColSubtotal = function(h, opts) {\n        $(h.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`).removeClass(classColExpanded).addClass(classColCollapsed).removeClass(classColHide).addClass(classColShow);\n        if (h.children.length !== 0) {\n          h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n        }\n        return h.th.colSpan = 1;\n      };\n      collapseChildCol = function(ch, h) {\n        var chKey, l, len, ref;\n        ref = ch.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          if (hasClass(ch[chKey].th, classColShow)) {\n            collapseChildCol(ch[chKey], h);\n          }\n        }\n        return hideChildCol(ch);\n      };\n      collapseCol = function(axisHeaders, h, opts) {\n        var chKey, colSpan, l, len, p, ref;\n        colSpan = h.th.colSpan - 1;\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          if (hasClass(h[chKey].th, classColShow)) {\n            collapseChildCol(h[chKey], h);\n          }\n        }\n        if (h.col < opts.disableFrom) {\n          if (hasClass(h.th, classColHide)) {\n            collapseHiddenColSubtotal(h, opts);\n          } else {\n            collapseShowColSubtotal(h, opts);\n          }\n        }\n        p = h.parent;\n        while (p) {\n          p.th.colSpan -= colSpan;\n          p = p.parent;\n        }\n        h.clickStatus = clickStatusCollapsed;\n        h.onClick = expandCol;\n        axisHeaders.ah[h.col].expandedCount--;\n        return adjustAxisHeader(axisHeaders, h.col, opts);\n      };\n      showChildCol = function(ch) {\n        return $(ch.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${ch.node}\\\"], th[data-colnode=\\\"${ch.node}\\\"]`).removeClass(classColHide).addClass(classColShow);\n      };\n      expandHideColSubtotal = function(h) {\n        $(h.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`).removeClass(`${classColCollapsed} ${classColShow}`).addClass(`${classColExpanded} ${classColHide}`);\n        replaceClass(h.th, classColHide, classColShow);\n        return h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n      };\n      expandShowColSubtotal = function(h) {\n        $(h.th).closest('table.pvtTable').find(`tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`).removeClass(`${classColCollapsed} ${classColHide}`).addClass(`${classColExpanded} ${classColShow}`);\n        h.th.colSpan++;\n        return h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n      };\n      expandChildCol = function(ch, opts) {\n        var chKey, l, len, ref, results;\n        if (ch.children.length !== 0 && opts.hideOnExpand && ch.clickStatus === clickStatusExpanded) {\n          replaceClass(ch.th, classColHide, classColShow);\n        } else {\n          showChildCol(ch);\n        }\n        if (ch.sTh && ch.clickStatus === clickStatusExpanded && opts.hideOnExpand) {\n          replaceClass(ch.sTh, classColShow, classColHide);\n        }\n        if (ch.clickStatus === clickStatusExpanded || ch.col >= opts.disableFrom) {\n          ref = ch.children;\n          results = [];\n          for (l = 0, len = ref.length; l < len; l++) {\n            chKey = ref[l];\n            results.push(expandChildCol(ch[chKey], opts));\n          }\n          return results;\n        }\n      };\n      expandCol = function(axisHeaders, h, opts) {\n        var ch, chKey, colSpan, l, len, p, ref;\n        if (h.clickStatus === clickStatusExpanded) {\n          adjustAxisHeader(axisHeaders, h.col, opts);\n          return;\n        }\n        colSpan = 0;\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          ch = h[chKey];\n          expandChildCol(ch, opts);\n          colSpan += ch.th.colSpan;\n        }\n        h.th.colSpan = colSpan;\n        if (h.col < opts.disableFrom) {\n          if (opts.hideOnExpand) {\n            expandHideColSubtotal(h);\n            --colSpan;\n          } else {\n            expandShowColSubtotal(h);\n          }\n        }\n        p = h.parent;\n        while (p) {\n          p.th.colSpan += colSpan;\n          p = p.parent;\n        }\n        h.clickStatus = clickStatusExpanded;\n        h.onClick = collapseCol;\n        axisHeaders.ah[h.col].expandedCount++;\n        return adjustAxisHeader(axisHeaders, h.col, opts);\n      };\n      hideChildRow = function(ch, opts) {\n        var cell, l, len, len1, o, ref, ref1, results;\n        ref = ch.tr.querySelectorAll(\"th, td\");\n        for (l = 0, len = ref.length; l < len; l++) {\n          cell = ref[l];\n          replaceClass(cell, classRowShow, classRowHide);\n        }\n        if (ch.sTr) {\n          ref1 = ch.sTr.querySelectorAll(\"th, td\");\n          results = [];\n          for (o = 0, len1 = ref1.length; o < len1; o++) {\n            cell = ref1[o];\n            results.push(replaceClass(cell, classRowShow, classRowHide));\n          }\n          return results;\n        }\n      };\n      collapseShowRowSubtotal = function(h, opts) {\n        var cell, l, len, len1, o, ref, ref1, results;\n        h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n        ref = h.tr.querySelectorAll(\"th, td\");\n        for (l = 0, len = ref.length; l < len; l++) {\n          cell = ref[l];\n          removeClass(cell, `${classRowExpanded} ${classRowHide}`);\n          addClass(cell, `${classRowCollapsed} ${classRowShow}`);\n        }\n        if (h.sTr) {\n          ref1 = h.sTr.querySelectorAll(\"th, td\");\n          results = [];\n          for (o = 0, len1 = ref1.length; o < len1; o++) {\n            cell = ref1[o];\n            removeClass(cell, `${classRowExpanded} ${classRowHide}`);\n            results.push(addClass(cell, `${classRowCollapsed} ${classRowShow}`));\n          }\n          return results;\n        }\n      };\n      collapseChildRow = function(ch, h, opts) {\n        var chKey, l, len, ref;\n        ref = ch.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          collapseChildRow(ch[chKey], h, opts);\n        }\n        return hideChildRow(ch, opts);\n      };\n      collapseRow = function(axisHeaders, h, opts) {\n        var chKey, l, len, ref;\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          collapseChildRow(h[chKey], h, opts);\n        }\n        collapseShowRowSubtotal(h, opts);\n        h.clickStatus = clickStatusCollapsed;\n        h.onClick = expandRow;\n        axisHeaders.ah[h.col].expandedCount--;\n        return adjustAxisHeader(axisHeaders, h.col, opts);\n      };\n      showChildRow = function(ch, opts) {\n        var cell, l, len, len1, o, ref, ref1, results;\n        ref = ch.tr.querySelectorAll(\"th, td\");\n        for (l = 0, len = ref.length; l < len; l++) {\n          cell = ref[l];\n          replaceClass(cell, classRowHide, classRowShow);\n        }\n        if (ch.sTr) {\n          ref1 = ch.sTr.querySelectorAll(\"th, td\");\n          results = [];\n          for (o = 0, len1 = ref1.length; o < len1; o++) {\n            cell = ref1[o];\n            results.push(replaceClass(cell, classRowHide, classRowShow));\n          }\n          return results;\n        }\n      };\n      expandShowRowSubtotal = function(h, opts) {\n        var cell, l, len, len1, o, ref, ref1, results;\n        h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n        ref = h.tr.querySelectorAll(\"th, td\");\n        for (l = 0, len = ref.length; l < len; l++) {\n          cell = ref[l];\n          removeClass(cell, `${classRowCollapsed} ${classRowHide}`);\n          addClass(cell, `${classRowExpanded} ${classRowShow}`);\n        }\n        if (h.sTr) {\n          ref1 = h.sTr.querySelectorAll(\"th, td\");\n          results = [];\n          for (o = 0, len1 = ref1.length; o < len1; o++) {\n            cell = ref1[o];\n            removeClass(cell, `${classRowCollapsed} ${classRowHide}`);\n            results.push(addClass(cell, `${classRowExpanded} ${classRowShow}`));\n          }\n          return results;\n        }\n      };\n      expandHideRowSubtotal = function(h, opts) {\n        var cell, l, len, len1, o, ref, ref1, results;\n        h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n        ref = h.tr.querySelectorAll(\"th, td\");\n        for (l = 0, len = ref.length; l < len; l++) {\n          cell = ref[l];\n          removeClass(cell, `${classRowCollapsed} ${classRowShow}`);\n          addClass(cell, `${classRowExpanded} ${classRowHide}`);\n        }\n        removeClass(h.th, `${classRowCollapsed} ${classRowHide}`);\n        addClass(cell, `${classRowExpanded} ${classRowShow}`);\n        if (h.sTr) {\n          ref1 = h.sTr.querySelectorAll(\"th, td\");\n          results = [];\n          for (o = 0, len1 = ref1.length; o < len1; o++) {\n            cell = ref1[o];\n            removeClass(cell, `${classRowCollapsed} ${classRowShow}`);\n            results.push(addClass(cell, `${classRowExpanded} ${classRowHide}`));\n          }\n          return results;\n        }\n      };\n      expandChildRow = function(ch, opts) {\n        var chKey, l, len, ref, results;\n        if (ch.children.length !== 0 && opts.hideOnExpand && ch.clickStatus === clickStatusExpanded) {\n          replaceClass(ch.th, classRowHide, classRowShow);\n        } else {\n          showChildRow(ch, opts);\n        }\n        if (ch.sTh && ch.clickStatus === clickStatusExpanded && opts.hideOnExpand) {\n          replaceClass(ch.sTh, classRowShow, classRowHide);\n        }\n        if (ch.clickStatus === clickStatusExpanded || ch.col >= opts.disableFrom) {\n          ref = ch.children;\n          results = [];\n          for (l = 0, len = ref.length; l < len; l++) {\n            chKey = ref[l];\n            results.push(expandChildRow(ch[chKey], opts));\n          }\n          return results;\n        }\n      };\n      expandRow = function(axisHeaders, h, opts) {\n        var ch, chKey, l, len, ref;\n        if (h.clickStatus === clickStatusExpanded) {\n          adjustAxisHeader(axisHeaders, h.col, opts);\n          return;\n        }\n        ref = h.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          ch = h[chKey];\n          expandChildRow(ch, opts);\n        }\n        if (h.children.length !== 0) {\n          if (opts.hideOnExpand) {\n            expandHideRowSubtotal(h, opts);\n          } else {\n            expandShowRowSubtotal(h, opts);\n          }\n        }\n        h.clickStatus = clickStatusExpanded;\n        h.onClick = collapseRow;\n        axisHeaders.ah[h.col].expandedCount++;\n        return adjustAxisHeader(axisHeaders, h.col, opts);\n      };\n      collapseAxis = function(axisHeaders, col, attrs, opts) {\n        var collapsible, h, i, l, ref, ref1, results;\n        collapsible = Math.min(attrs.length - 2, opts.disableFrom - 1);\n        if (col > collapsible) {\n          return;\n        }\n        results = [];\n        for (i = l = ref = collapsible, ref1 = col; l >= ref1; i = l += -1) {\n          results.push((function() {\n            var len, o, ref2, results1;\n            ref2 = axisHeaders.ah[i].attrHeaders;\n            results1 = [];\n            for (o = 0, len = ref2.length; o < len; o++) {\n              h = ref2[o];\n              if (h.clickStatus === clickStatusExpanded && h.children.length !== 0) {\n                results1.push(axisHeaders.collapseAttrHeader(axisHeaders, h, opts));\n              }\n            }\n            return results1;\n          })());\n        }\n        return results;\n      };\n      expandAxis = function(axisHeaders, col, attrs, opts) {\n        var ah, h, i, l, ref, results;\n        ah = axisHeaders.ah[col];\n        results = [];\n        for (i = l = 0, ref = col; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {\n          results.push((function() {\n            var len, o, ref1, results1;\n            ref1 = axisHeaders.ah[i].attrHeaders;\n            results1 = [];\n            for (o = 0, len = ref1.length; o < len; o++) {\n              h = ref1[o];\n              results1.push(axisHeaders.expandAttrHeader(axisHeaders, h, opts));\n            }\n            return results1;\n          })());\n        }\n        return results;\n      };\n      // when h.clickStatus is clickStatusCollapsed and h.children.length isnt 0 for i in [0..col]\n      main = function(rowAttrs, rowKeys, colAttrs, colKeys) {\n        var ah, chKey, colAttrHeaders, colAxisHeaders, colKeyHeaders, index, l, len, len1, len2, node, o, q, ref, ref1, ref2, result, rowAttrHeaders, rowAxisHeaders, rowKeyHeaders, tableClasses, tbody, thead, tr;\n        rowAttrHeaders = [];\n        colAttrHeaders = [];\n        if (colAttrs.length !== 0 && colKeys.length !== 0) {\n          colKeyHeaders = processKeys(colKeys, \"pvtColLabel\");\n        }\n        if (rowAttrs.length !== 0 && rowKeys.length !== 0) {\n          rowKeyHeaders = processKeys(rowKeys, \"pvtRowLabel\");\n        }\n        if (colKeyHeaders && !useLookerRowTotals) {\n          delete colKeyHeaders[LOOKER_ROW_TOTAL_KEY];\n          colKeyHeaders.children = colKeyHeaders.children.filter(function(k) {\n            return k !== LOOKER_ROW_TOTAL_KEY;\n          });\n        }\n        tableClasses = \"pvtTable\";\n        if (hasRowTotals) {\n          tableClasses += \" pvtHasRowTotals\";\n        }\n        if (hasColTotals) {\n          tableClasses += \" pvtHasColTotals\";\n        }\n        result = createElement(\"table\", tableClasses, null, {\n          style: \"display: none;\"\n        });\n        thead = createElement(\"thead\");\n        result.appendChild(thead);\n        if (colAttrs.length !== 0) {\n          colAxisHeaders = buildColAxisHeaders(thead, rowAttrs, colAttrs, opts);\n          node = {\n            counter: 0\n          };\n          ref = colKeyHeaders.children;\n          for (l = 0, len = ref.length; l < len; l++) {\n            chKey = ref[l];\n            buildColHeader(colAxisHeaders, colAttrHeaders, colKeyHeaders[chKey], rowAttrs, colAttrs, node, opts);\n          }\n          if (hasRowTotals && !useLookerRowTotals) {\n            ref1 = colAxisHeaders.ah;\n            for (index = o = 0, len1 = ref1.length; o < len1; index = ++o) {\n              ah = ref1[index];\n              if (index === colAxisHeaders.ah.length - 1) {\n                buildRowTotalsHeader(ah.tr, null, rowAttrs, colAttrs);\n              } else {\n                ah.tr.appendChild(createElement(\"th\", \"pvtColTotalFiller\", null, {\n                  colspan: colAttrs.length\n                }));\n              }\n            }\n          }\n        }\n        tbody = createElement(\"tbody\");\n        result.appendChild(tbody);\n        if (rowAttrs.length !== 0) {\n          rowAxisHeaders = buildRowAxisHeaders(thead, rowAttrs, colAttrs, opts);\n          buildRowTotalsHeader(rowAxisHeaders.tr, colKeyHeaders, rowAttrs, colAttrs);\n          node = {\n            counter: 0\n          };\n          ref2 = rowKeyHeaders.children;\n          for (q = 0, len2 = ref2.length; q < len2; q++) {\n            chKey = ref2[q];\n            buildRowHeader(tbody, rowAxisHeaders, rowAttrHeaders, rowKeyHeaders[chKey], rowAttrs, colAttrs, node, opts);\n          }\n        }\n        buildValues(tbody, colAttrHeaders, rowAttrHeaders, rowAttrs, colAttrs, opts);\n        if (hasColTotals) {\n          tr = buildColTotalsHeader(rowAttrs, colAttrs);\n          if (colAttrs.length > 0) {\n            buildColTotals(tr, colAttrHeaders, rowAttrs, colAttrs, opts);\n          }\n          if (hasRowTotals && !useLookerRowTotals) {\n            buildGrandTotal(tbody, tr, rowAttrs, colAttrs, opts);\n          }\n          tbody.appendChild(tr);\n        }\n        collapseAxis(colAxisHeaders, opts.colSubtotalDisplay.collapseAt, colAttrs, opts.colSubtotalDisplay);\n        collapseAxis(rowAxisHeaders, opts.rowSubtotalDisplay.collapseAt, rowAttrs, opts.rowSubtotalDisplay);\n        result.setAttribute(\"data-numrows\", rowKeys.length);\n        result.setAttribute(\"data-numcols\", colKeys.length);\n        result.style.display = \"\";\n        return result;\n      };\n      return main(rowAttrs, rowKeys, colAttrs, colKeys);\n    };\n    $.pivotUtilities.subtotal_renderers = {\n      \"Table With Subtotal\": function(pvtData, opts) {\n        return SubtotalRenderer(pvtData, opts);\n      },\n      \"Table With Subtotal Bar Chart\": function(pvtData, opts) {\n        return $(SubtotalRenderer(pvtData, opts)).barchart();\n      },\n      \"Table With Subtotal Heatmap\": function(pvtData, opts) {\n        return $(SubtotalRenderer(pvtData, opts)).heatmap(\"heatmap\", opts);\n      },\n      \"Table With Subtotal Row Heatmap\": function(pvtData, opts) {\n        return $(SubtotalRenderer(pvtData, opts)).heatmap(\"rowheatmap\", opts);\n      },\n      \"Table With Subtotal Col Heatmap\": function(pvtData, opts) {\n        return $(SubtotalRenderer(pvtData, opts)).heatmap(\"colheatmap\", opts);\n      }\n    };\n    \n    // Aggregators\n\n    usFmtPct = $.pivotUtilities.numberFormat({\n      digitsAfterDecimal: 1,\n      scaler: 100,\n      suffix: \"%\"\n    });\n    aggregatorTemplates = $.pivotUtilities.aggregatorTemplates;\n    subtotalAggregatorTemplates = {\n      fractionOf: function(wrapped, type = \"row\", formatter = usFmtPct) {\n        return function(...x) {\n          return function(data, rowKey, colKey) {\n            if (typeof rowKey === \"undefined\") {\n              rowKey = [];\n            }\n            if (typeof colKey === \"undefined\") {\n              colKey = [];\n            }\n            return {\n              selector: {\n                row: [rowKey.slice(0, -1), []],\n                col: [[], colKey.slice(0, -1)]\n              }[type],\n              inner: wrapped(...x)(data, rowKey, colKey),\n              push: function(record) {\n                return this.inner.push(record);\n              },\n              format: formatter,\n              value: function() {\n                return this.inner.value() / data.getAggregator(...this.selector).inner.value();\n              },\n              numInputs: wrapped(...x)().numInputs\n            };\n          };\n        };\n      }\n    };\n    $.pivotUtilities.subtotalAggregatorTemplates = subtotalAggregatorTemplates;\n    return $.pivotUtilities.subtotal_aggregators = (function(tpl, sTpl) {\n      return {\n        \"Sum As Fraction Of Parent Row\": sTpl.fractionOf(tpl.sum(), \"row\", usFmtPct),\n        \"Sum As Fraction Of Parent Column\": sTpl.fractionOf(tpl.sum(), \"col\", usFmtPct),\n        \"Count As Fraction Of Parent Row\": sTpl.fractionOf(tpl.count(), \"row\", usFmtPct),\n        \"Count As Fraction Of Parent Column\": sTpl.fractionOf(tpl.count(), \"col\", usFmtPct)\n      };\n    })(aggregatorTemplates, subtotalAggregatorTemplates);\n  });\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });
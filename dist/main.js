/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = flatten\nmodule.exports.from = flattenFrom\nmodule.exports.depth = flattenDepth\nmodule.exports.fromDepth = flattenFromDepth\n\n/**\n * Flatten an array.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flatten (array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFrom(array)\n}\n\n/**\n * Flatten an array-like structure.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flattenFrom (array) {\n  return flattenDown(array, [])\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDepth (array, depth) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFromDepth(array, depth)\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenFromDepth (array, depth) {\n  if (typeof depth !== 'number') {\n    throw new TypeError('Expected the depth to be a number')\n  }\n\n  return flattenDownDepth(array, [], depth)\n}\n\n/**\n * Flatten an array indefinitely.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenDown (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDownDepth (array, result, depth) {\n  depth--\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > -1 && Array.isArray(value)) {\n      flattenDownDepth(value, result, depth)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack:///./node_modules/array-flatten/array-flatten.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! array-flatten */ \"./node_modules/array-flatten/array-flatten.js\");\n/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(array_flatten__WEBPACK_IMPORTED_MODULE_0__);\n\n\nlet hasProp = {}.hasOwnProperty;\nlet callWithJQuery = function(pivotModule) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    return (module.exports = pivotModule);\n  } else if (typeof define === \"function\" && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    // AMD\n    return define([\"jquery\"], pivotModule);\n  } else {\n    // Plain browser env\n    return pivotModule(jQuery);\n  }\n};\n\ncallWithJQuery(function($) {\n  var LOOKER_ROW_TOTAL_KEY,\n    SubtotalPivotDataMulti,\n    SubtotalRenderer,\n    aggregatorTemplates,\n    subtotalAggregatorTemplates,\n    usFmtPct;\n  LOOKER_ROW_TOTAL_KEY = \"$$$_row_total_$$$\";\n  SubtotalPivotDataMulti = function() {\n    var processKey;\n\n    class SubtotalPivotDataMulti extends $.pivotUtilities.PivotData {\n      constructor(input, opts) {\n        var i, l, len, name, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n        super(input, opts);\n        this.hasColTotals = (ref = opts.hasColTotals) != null ? ref : true;\n        this.hasRowTotals = this.colAttrs.length\n          ? (ref1 = opts.hasRowTotals) != null\n            ? ref1\n            : true\n          : true;\n        this.labels = (ref2 = opts.labels) != null ? ref2 : {};\n        // Multiple aggregator hack: Let clients pass in aggregators\n        // (plural) and use the first one as the main value for each cell.\n        this.aggregatorNames =\n          (ref3 = opts.aggregatorNames) != null ? ref3 : [\"Count\"];\n        this.aggregators =\n          (ref4 = opts.aggregators) != null\n            ? ref4\n            : function() {\n                var l, len, ref5, results;\n                ref5 = this.aggregatorNames;\n                results = [];\n                for (l = 0, len = ref5.length; l < len; l++) {\n                  name = ref5[l];\n                  results.push($.pivotUtilities.aggregators[name]({}));\n                }\n                return results;\n              }.call(this);\n        this.aggregatorName = this.aggregatorNames[0];\n        this.aggregator = this.aggregators[0];\n        if (this.aggregatorNames.length !== this.aggregators.length) {\n          throw new Error(\n            \"aggregators and aggregatorNames must be the same length\"\n          );\n        }\n        this.allTotal = {};\n        ref5 = this.aggregatorNames;\n        for (i = l = 0, len = ref5.length; l < len; i = ++l) {\n          name = ref5[i];\n          this.allTotal[name] = this.aggregators[i](this, [], []);\n        }\n        SubtotalPivotDataMulti.forEachRecord(\n          this.input,\n          this.derivedAttributes,\n          record => {\n            if (this.filter(record)) {\n              return this.processRecord(record);\n            }\n          }\n        );\n        this.hasLookerRowTotals = array_flatten__WEBPACK_IMPORTED_MODULE_0___default()(this.getColKeys()).includes(\n          LOOKER_ROW_TOTAL_KEY\n        );\n        this.useLookerRowTotals =\n          ((ref6 = opts.useLookerRowTotals) != null ? ref6 : true) &&\n          this.hasLookerRowTotals;\n      }\n\n      processRecord(record) {\n        //this code is called in a tight loop\n        var addKey,\n          aggregator,\n          attr,\n          base,\n          base1,\n          colKey,\n          fColKey,\n          fRowKey,\n          flatColKey,\n          flatKey,\n          flatRowKey,\n          i,\n          j,\n          k,\n          l,\n          len,\n          len1,\n          len2,\n          len3,\n          len4,\n          len5,\n          len6,\n          len7,\n          m,\n          n,\n          name,\n          o,\n          q,\n          r,\n          ref,\n          ref1,\n          ref10,\n          ref11,\n          ref2,\n          ref3,\n          ref4,\n          ref5,\n          ref6,\n          ref7,\n          ref8,\n          ref9,\n          rowKey,\n          s,\n          t,\n          u,\n          w,\n          y,\n          z;\n\n        // Since this gets called in the PivotData (superclass) constructor\n        // but we haven't yet initialized @aggregators, don't do anything.\n        if (!this.aggregators) {\n          return;\n        }\n        rowKey = [];\n        addKey = false;\n        ref = this.rowAttrs;\n        for (l = 0, len = ref.length; l < len; l++) {\n          attr = ref[l];\n          rowKey.push((ref1 = record[attr]) != null ? ref1 : \"null\");\n          flatKey = rowKey.join(String.fromCharCode(0));\n          if (!this.rowTotals[flatKey]) {\n            this.rowTotals[flatKey] = {};\n            ref2 = this.aggregatorNames;\n            for (i = o = 0, len1 = ref2.length; o < len1; i = ++o) {\n              name = ref2[i];\n              aggregator = this.aggregators[i];\n              this.rowTotals[flatKey][name] = aggregator(\n                this,\n                rowKey.slice(),\n                []\n              );\n              addKey = true;\n            }\n          }\n          if (\n            this.colAttrs.length &&\n            record[this.colAttrs[0]] === LOOKER_ROW_TOTAL_KEY\n          ) {\n            // Don't aggregate alread-aggregated data.\n            continue;\n          }\n          ref3 = this.aggregatorNames;\n          for (q = 0, len2 = ref3.length; q < len2; q++) {\n            name = ref3[q];\n            this.rowTotals[flatKey][name].push(record);\n          }\n        }\n        if (addKey) {\n          this.rowKeys.push(rowKey);\n        }\n        colKey = [];\n        addKey = false;\n        ref4 = this.colAttrs;\n        for (r = 0, len3 = ref4.length; r < len3; r++) {\n          attr = ref4[r];\n          colKey.push((ref5 = record[attr]) != null ? ref5 : \"null\");\n          flatKey = colKey.join(String.fromCharCode(0));\n          if (!this.colTotals[flatKey]) {\n            this.colTotals[flatKey] = {};\n            ref6 = this.aggregatorNames;\n            for (i = s = 0, len4 = ref6.length; s < len4; i = ++s) {\n              name = ref6[i];\n              aggregator = this.aggregators[i];\n              this.colTotals[flatKey][name] = aggregator(\n                this,\n                [],\n                colKey.slice()\n              );\n              addKey = true;\n            }\n          }\n          ref7 = this.aggregatorNames;\n          for (t = 0, len5 = ref7.length; t < len5; t++) {\n            name = ref7[t];\n            this.colTotals[flatKey][name].push(record);\n          }\n        }\n        if (addKey) {\n          this.colKeys.push(colKey);\n        }\n        if (colKey[0] !== LOOKER_ROW_TOTAL_KEY) {\n          ref8 = this.aggregatorNames;\n          for (u = 0, len6 = ref8.length; u < len6; u++) {\n            name = ref8[u];\n            this.allTotal[name].push(record);\n          }\n        }\n        m = rowKey.length - 1;\n        n = colKey.length - 1;\n        if (m < 0 || n < 0) {\n          return;\n        }\n        for (\n          i = w = 0, ref9 = m;\n          0 <= ref9 ? w <= ref9 : w >= ref9;\n          i = 0 <= ref9 ? ++w : --w\n        ) {\n          fRowKey = rowKey.slice(0, i + 1);\n          flatRowKey = fRowKey.join(String.fromCharCode(0));\n          if ((base = this.tree)[flatRowKey] == null) {\n            base[flatRowKey] = {};\n          }\n          for (\n            j = y = 0, ref10 = n;\n            0 <= ref10 ? y <= ref10 : y >= ref10;\n            j = 0 <= ref10 ? ++y : --y\n          ) {\n            fColKey = colKey.slice(0, j + 1);\n            flatColKey = fColKey.join(String.fromCharCode(0));\n            if ((base1 = this.tree[flatRowKey])[flatColKey] == null) {\n              base1[flatColKey] = {};\n            }\n            ref11 = this.aggregatorNames;\n            for (k = z = 0, len7 = ref11.length; z < len7; k = ++z) {\n              name = ref11[k];\n              aggregator = this.aggregators[k];\n              if (!this.tree[flatRowKey][flatColKey][name]) {\n                this.tree[flatRowKey][flatColKey][name] = aggregator(\n                  this,\n                  fRowKey,\n                  fColKey\n                );\n              }\n              this.tree[flatRowKey][flatColKey][name].push(record);\n            }\n          }\n        }\n      }\n    }\n\n    processKey = function(record, totals, keys, attrs, getAggregator) {\n      var addKey, attr, flatKey, key, l, len, ref;\n      key = [];\n      addKey = false;\n      for (l = 0, len = attrs.length; l < len; l++) {\n        attr = attrs[l];\n        key.push((ref = record[attr]) != null ? ref : \"null\");\n        flatKey = key.join(String.fromCharCode(0));\n        if (!totals[flatKey]) {\n          totals[flatKey] = getAggregator(key.slice());\n          addKey = true;\n        }\n        totals[flatKey].push(record);\n      }\n      if (addKey) {\n        keys.push(key);\n      }\n      return key;\n    };\n\n    return SubtotalPivotDataMulti;\n  }.call(this);\n  $.pivotUtilities.SubtotalPivotDataMulti = SubtotalPivotDataMulti;\n  SubtotalRenderer = function(pivotData, opts) {\n    var childNumberToCollapse,\n      addClass,\n      adjustAxisHeader,\n      aggregatorNames,\n      aggregators,\n      allTotal,\n      arrowCollapsed,\n      arrowExpanded,\n      buildAxisHeader,\n      buildColAxisHeaders,\n      buildColHeader,\n      buildColTotals,\n      buildColTotalsHeader,\n      buildGrandTotal,\n      buildRowAxisHeaders,\n      buildRowHeader,\n      buildRowTotalsHeader,\n      buildValues,\n      classColCollapsed,\n      classColExpanded,\n      classColHide,\n      classColShow,\n      classCollapsed,\n      classExpanded,\n      classRowCollapsed,\n      classRowExpanded,\n      classRowHide,\n      classRowShow,\n      clickStatusCollapsed,\n      clickStatusExpanded,\n      colAttrs,\n      colKeys,\n      colTotals,\n      collapseAxis,\n      collapseAxisHeaders,\n      collapseChildCol,\n      collapseChildRow,\n      collapseChildRows,\n      collapseCol,\n      collapseHiddenColSubtotal,\n      collapseRow,\n      collapseShowColSubtotal,\n      collapseShowRowSubtotal,\n      createElement,\n      defaults,\n      escapeHtml,\n      expandAxis,\n      expandChildCol,\n      expandChildRow,\n      expandCol,\n      expandHideColSubtotal,\n      expandHideRowSubtotal,\n      expandRow,\n      expandShowColSubtotal,\n      expandShowRowSubtotal,\n      getHeaderText,\n      getTableEventHandlers,\n      hasClass,\n      hasColTotals,\n      hasLookerRowTotals,\n      hasRowTotals,\n      hideChildCol,\n      hideChildRow,\n      labels,\n      lastPivotHeader,\n      main,\n      parseLabel,\n      processKeys,\n      removeClass,\n      replaceClass,\n      rowAttrs,\n      rowKeys,\n      rowTotals,\n      setAttributes,\n      showChildCol,\n      showChildRow,\n      showSubtotalFromIndex,\n      tree,\n      useLookerRowTotals;\n    defaults = {\n      table: {\n        clickCallback: null\n      },\n      localeStrings: {\n        totals: \"Totals\",\n        subtotalOf: \"Subtotal of\"\n      },\n      arrowCollapsed: \"\\u25B6\",\n      arrowExpanded: \"\\u25E2\",\n      rowSubtotalDisplay: {\n        displayOnTop: true,\n        disableFrom: 99999,\n        collapseAt: 99999,\n        hideOnExpand: true,\n        disableExpandCollapse: false\n      },\n      colSubtotalDisplay: {\n        displayOnTop: true,\n        disableFrom: 0,\n        collapseAt: 0,\n        hideOnExpand: false,\n        disableExpandCollapse: false\n      },\n      showSubtotalFromIndex: 0 \n    };\n    opts = $.extend(true, {}, defaults, opts);\n    if (opts.rowSubtotalDisplay.disableSubtotal) {\n      opts.rowSubtotalDisplay.disableFrom = 0;\n    }\n    if (\n      typeof opts.rowSubtotalDisplay.disableAfter !== \"undefined\" &&\n      opts.rowSubtotalDisplay.disableAfter !== null\n    ) {\n      opts.rowSubtotalDisplay.disableFrom =\n        opts.rowSubtotalDisplay.disableAfter + 1;\n    }\n    if (\n      typeof opts.rowSubtotalDisplay.collapseAt !== \"undefined\" &&\n      opts.collapseRowsAt !== null\n    ) {\n      opts.rowSubtotalDisplay.collapseAt = opts.collapseRowsAt;\n    }\n    if (opts.colSubtotalDisplay.disableSubtotal) {\n      opts.colSubtotalDisplay.disableFrom = 0;\n    }\n    if (\n      typeof opts.colSubtotalDisplay.disableAfter !== \"undefined\" &&\n      opts.colSubtotalDisplay.disableAfter !== null\n    ) {\n      opts.colSubtotalDisplay.disableFrom =\n        opts.colSubtotalDisplay.disableAfter + 1;\n    }\n    if (\n      typeof opts.colSubtotalDisplay.collapseAt !== \"undefined\" &&\n      opts.collapseColsAt !== null\n    ) {\n      opts.colSubtotalDisplay.collapseAt = opts.collapseColsAt;\n    }\n    if (opts.colSubtotalDisplay.disableFrom > 0) {\n      throw new Error(\"Column subtotals are unimplemented\");\n    }\n    colAttrs = pivotData.colAttrs;\n    rowAttrs = pivotData.rowAttrs;\n    rowKeys = pivotData.getRowKeys();\n    colKeys = pivotData.getColKeys();\n    tree = pivotData.tree;\n    rowTotals = pivotData.rowTotals;\n    colTotals = pivotData.colTotals;\n    allTotal = pivotData.allTotal;\n    aggregators = pivotData.aggregators;\n    aggregatorNames = pivotData.aggregatorNames;\n    hasColTotals = pivotData.hasColTotals;\n    hasRowTotals = pivotData.hasRowTotals;\n    labels = pivotData.labels;\n    hasLookerRowTotals = pivotData.hasLookerRowTotals;\n    useLookerRowTotals = pivotData.useLookerRowTotals;\n    classRowHide = \"rowhide\";\n    classRowShow = \"rowshow\";\n    classColHide = \"colhide\";\n    classColShow = \"colshow\";\n    clickStatusExpanded = \"expanded\";\n    clickStatusCollapsed = \"collapsed\";\n    classExpanded = \"expanded\";\n    classCollapsed = \"collapsed\";\n    classRowExpanded = \"rowexpanded\";\n    classRowCollapsed = \"rowcollapsed\";\n    classColExpanded = \"colexpanded\";\n    classColCollapsed = \"colcollapsed\";\n    arrowExpanded = opts.arrowExpanded;\n    arrowCollapsed = opts.arrowCollapsed;\n    childNumberToCollapse = 1;\n    showSubtotalFromIndex = opts.showSubtotalFromIndex; //when rowSubtotalDisplay.hideOnExpand is true, this force subtotal row show usign columns indexes. \n    // Based on http://stackoverflow.com/questions/195951/change-an-elements-class-with-javascript -- Begin\n    hasClass = function(element, className) {\n      var regExp;\n      regExp = new RegExp(\"(?:^|\\\\s)\" + className + \"(?!\\\\S)\", \"g\");\n      return element.className.match(regExp) !== null;\n    };\n    removeClass = function(element, className) {\n      var l, len, name, ref, regExp, results;\n      ref = className.split(\" \");\n      results = [];\n      for (l = 0, len = ref.length; l < len; l++) {\n        name = ref[l];\n        regExp = new RegExp(\"(?:^|\\\\s)\" + name + \"(?!\\\\S)\", \"g\");\n        results.push(\n          (element.className = element.className.replace(regExp, \"\"))\n        );\n      }\n      return results;\n    };\n    addClass = function(element, className) {\n      var l, len, name, ref, results;\n      ref = className.split(\" \");\n      results = [];\n      for (l = 0, len = ref.length; l < len; l++) {\n        name = ref[l];\n        if (!hasClass(element, name)) {\n          results.push((element.className += \" \" + name));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n    replaceClass = function(element, replaceClassName, byClassName) {\n      removeClass(element, replaceClassName);\n      return addClass(element, byClassName);\n    };\n    // Based on http://stackoverflow.com/questions/195951/change-an-elements-class-with-javascript -- End\n    escapeHtml = function(unsafe) {\n      return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n    };\n    parseLabel = function(parts) {\n      var append, out;\n      // Safe way to insert stylized labels. Parts can be a string or object { label, subabel }, or array as such.\n      out = \"\";\n      append = function(value) {\n        var l, len, results, x;\n        if (Array.isArray(value)) {\n          results = [];\n          for (l = 0, len = value.length; l < len; l++) {\n            x = value[l];\n            results.push(append(x));\n          }\n          return results;\n        } else if (value != null ? value.label : void 0) {\n          out += escapeHtml(value.label);\n          if (value.sublabel) {\n            return (out += ` <em>${escapeHtml(value.sublabel)}</em>`);\n          }\n        } else if (value !== null && value !== void 0) {\n          return (out += escapeHtml(String(value)));\n        }\n      };\n      append(parts);\n      return out;\n    };\n    createElement = function(\n      elementType,\n      className,\n      label,\n      attributes,\n      eventHandlers\n    ) {\n      var attr, e, event, handler, val;\n      e = document.createElement(elementType);\n      if (className != null) {\n        e.className = className;\n      }\n      e.innerHTML = parseLabel(label);\n      if (attributes != null) {\n        for (attr in attributes) {\n          if (!hasProp.call(attributes, attr)) continue;\n          val = attributes[attr];\n          e.setAttribute(attr, val);\n        }\n      }\n      if (eventHandlers != null) {\n        for (event in eventHandlers) {\n          if (!hasProp.call(eventHandlers, event)) continue;\n          handler = eventHandlers[event];\n          e.addEventListener(event, handler);\n        }\n      }\n      return e;\n    };\n    setAttributes = function(e, attrs) {\n      var a, results, v;\n      results = [];\n      for (a in attrs) {\n        if (!hasProp.call(attrs, a)) continue;\n        v = attrs[a];\n        results.push(e.setAttribute(a, v));\n      }\n      return results;\n    };\n    processKeys = function(keysArr, className, opts) {\n      var headers, lastIdx, row;\n      lastIdx = keysArr[0].length - 1;\n      headers = {\n        children: []\n      };\n      row = 0;\n      keysArr.reduce((val0, k0) => {\n        var col;\n        col = 0;\n        k0.reduce((acc, curVal, curIdx, arr) => {\n          var i, key, l, node, ref;\n          if (!acc[curVal]) {\n            key = k0.slice(0, col + 1);\n            acc[curVal] = {\n              row: row,\n              col: col,\n              descendants: 0,\n              children: [],\n              text: curVal,\n              key: key,\n              flatKey: key.join(String.fromCharCode(0)),\n              firstLeaf: null,\n              leaves: 0,\n              parent: col !== 0 ? acc : null,\n              th: createElement(\"th\", className, curVal),\n              childrenSpan: 0\n            };\n            acc.children.push(curVal);\n          }\n          if (col > 0) {\n            acc.descendants++;\n          }\n          col++;\n          if (curIdx === lastIdx) {\n            node = headers;\n            for (\n              i = l = 0, ref = lastIdx - 1;\n              0 <= ref ? l <= ref : l >= ref;\n              i = 0 <= ref ? ++l : --l\n            ) {\n              if (!(lastIdx > 0)) {\n                continue;\n              }\n              node[k0[i]].leaves++;\n              if (!node[k0[i]].firstLeaf) {\n                node[k0[i]].firstLeaf = acc[curVal];\n              }\n              node = node[k0[i]];\n            }\n            return headers;\n          }\n          return acc[curVal];\n        }, headers);\n        row++;\n        return headers;\n      }, headers);\n      return headers;\n    };\n    buildAxisHeader = function(axisHeaders, col, attrs, opts) {\n      var ah, arrow, hClass, ref;\n      ah = {\n        text: (ref = labels[attrs[col]]) != null ? ref : attrs[col],\n        expandedCount: 0,\n        expandables: 0,\n        attrHeaders: [],\n        clickStatus: clickStatusExpanded,\n        onClick: collapseAxis\n      };\n      arrow = `${arrowExpanded} `;\n      hClass = classExpanded;\n      if (col >= opts.collapseAt) {\n        arrow = `${arrowCollapsed} `;\n        hClass = classCollapsed;\n        ah.clickStatus = clickStatusCollapsed;\n        ah.onClick = expandAxis;\n      }\n      if (\n        col === attrs.length - 1 ||\n        col >= opts.disableFrom ||\n        opts.disableExpandCollapse\n      ) {\n        arrow = \"\";\n      }\n      ah.th = createElement(\"th\", `pvtAxisLabel ${hClass}`, [arrow, ah.text]);\n      if (\n        col < attrs.length - 1 &&\n        col < opts.disableFrom &&\n        !opts.disableExpandCollapse\n      ) {\n        ah.th.onclick = function(event) {\n          event = event || window.event;\n          return ah.onClick(axisHeaders, col, attrs, opts);\n        };\n      }\n      axisHeaders.ah.push(ah);\n      return ah;\n    };\n    buildColAxisHeaders = function(thead, rowAttrs, colAttrs, opts) {\n      var ah, attr, axisHeaders, col, l, len;\n      axisHeaders = {\n        collapseAttrHeader: collapseCol,\n        expandAttrHeader: expandCol,\n        ah: []\n      };\n      for (col = l = 0, len = colAttrs.length; l < len; col = ++l) {\n        attr = colAttrs[col];\n        ah = buildAxisHeader(\n          axisHeaders,\n          col,\n          colAttrs,\n          opts.colSubtotalDisplay\n        );\n        ah.th.colSpan = rowAttrs.length;\n        ah.tr = createElement(\"tr\", \"pvtColAxisHeaders\");\n        ah.tr.appendChild(ah.th);\n        thead.appendChild(ah.tr);\n      }\n      return axisHeaders;\n    };\n    buildRowAxisHeaders = function(thead, rowAttrs, colAttrs, opts) {\n      var ah, axisHeaders, col, l, ref;\n      axisHeaders = {\n        collapseAttrHeader: collapseRow,\n        expandAttrHeader: expandRow,\n        ah: [],\n        tr: createElement(\"tr\", \"pvtRowAxisHeaders\")\n      };\n      for (\n        col = l = 0, ref = rowAttrs.length - 1;\n        0 <= ref ? l <= ref : l >= ref;\n        col = 0 <= ref ? ++l : --l\n      ) {\n        ah = buildAxisHeader(\n          axisHeaders,\n          col,\n          rowAttrs,\n          opts.rowSubtotalDisplay\n        );\n        axisHeaders.tr.appendChild(ah.th);\n      }\n      thead.appendChild(axisHeaders.tr);\n      return axisHeaders;\n    };\n    getHeaderText = function(h, attrs, opts) {\n      var arrow, label;\n      arrow = ` ${arrowExpanded} `;\n      if (\n        h.col === attrs.length - 1 ||\n        h.col >= opts.disableFrom ||\n        opts.disableExpandCollapse ||\n        h.children.length === 0\n      ) {\n        arrow = \"\";\n      }\n      label = h.text === LOOKER_ROW_TOTAL_KEY ? \"Total\" : h.text;\n      return `${arrow}${label}`;\n    };\n    buildColHeader = function(\n      axisHeaders,\n      attrHeaders,\n      h,\n      rowAttrs,\n      colAttrs,\n      node,\n      opts\n    ) {\n      var ah, chKey, l, len, ref, ref1;\n      ref = h.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        // DF Recurse\n        buildColHeader(\n          axisHeaders,\n          attrHeaders,\n          h[chKey],\n          rowAttrs,\n          colAttrs,\n          node,\n          opts\n        );\n      }\n      // Process\n      ah = axisHeaders.ah[h.col];\n      ah.attrHeaders.push(h);\n      h.node = node.counter;\n      h.onClick = collapseCol;\n      addClass(\n        h.th,\n        `${classColShow} col${h.row} colcol${h.col} ${classColExpanded}`\n      );\n      h.th.setAttribute(\"data-colnode\", h.node);\n      h.th.colSpan = h.children.length\n        ? h.childrenSpan\n        : aggregatorNames.length;\n      //h.th.rowSpan = 2 if h.children.length is 0 and rowAttrs.length isnt 0\n      h.th.innerHTML = getHeaderText(h, colAttrs, opts.colSubtotalDisplay);\n      if (\n        h.children.length !== 0 &&\n        h.col < opts.colSubtotalDisplay.disableFrom\n      ) {\n        ah.expandables++;\n        ah.expandedCount += 1;\n        if (!opts.colSubtotalDisplay.hideOnExpand) {\n          h.th.colSpan++;\n        }\n        if (!opts.colSubtotalDisplay.disableExpandCollapse) {\n          h.th.onclick = function(event) {\n            event = event || window.event;\n            return h.onClick(axisHeaders, h, opts.colSubtotalDisplay);\n          };\n        }\n        h.sTh = createElement(\n          \"th\",\n          `pvtColLabelFiller ${classColShow} col${h.row} colcol${h.col} ${classColExpanded}`\n        );\n        h.sTh.setAttribute(\"data-colnode\", h.node);\n        if (opts.colSubtotalDisplay.hideOnExpand) {\n          // h.sTh.rowSpan = colAttrs.length-h.col\n          replaceClass(h.sTh, classColShow, classColHide);\n        }\n        h[h.children[0]].tr.appendChild(h.sTh);\n      }\n      if ((ref1 = h.parent) != null) {\n        ref1.childrenSpan += h.th.colSpan;\n      }\n      h.clickStatus = clickStatusExpanded;\n      if (h.text === LOOKER_ROW_TOTAL_KEY) {\n        if (!h.children.length) {\n          //h.th.rowSpan = colAttrs.length\n          addClass(h.th, \"pvtColTotal\");\n          ah.tr.appendChild(h.th);\n          h.tr = ah.tr;\n        } else {\n          ah.tr.appendChild(\n            createElement(\"th\", null, null, {\n              colspan: aggregatorNames.length\n            })\n          );\n        }\n      } else {\n        ah.tr.appendChild(h.th);\n        h.tr = ah.tr;\n      }\n      attrHeaders.push(h);\n      return node.counter++;\n    };\n    buildRowTotalsHeader = function(tr, colKeyHeaders, rowAttrs, colAttrs) {\n      var addHeaders, child, l, len, len1, len2, len3, name, o, q, r, ref, th;\n      if (colAttrs.length > 0) {\n        // We have pivots.\n        if (colKeyHeaders) {\n          addHeaders = function(headers) {\n            var child, l, len, len1, name, o, ref, results, results1, th;\n            if (headers.children.length > 0) {\n              ref = headers.children;\n              results = [];\n              for (l = 0, len = ref.length; l < len; l++) {\n                child = ref[l];\n                if (child === LOOKER_ROW_TOTAL_KEY) {\n                  continue;\n                }\n                results.push(addHeaders(headers[child]));\n              }\n              return results;\n            } else {\n              results1 = [];\n              for (o = 0, len1 = aggregatorNames.length; o < len1; o++) {\n                name = aggregatorNames[o];\n                th = createElement(\"th\", \"rowTotal\", labels[name]);\n                results1.push(tr.appendChild(th));\n              }\n              return results1;\n            }\n          };\n          addHeaders(colKeyHeaders);\n          if (useLookerRowTotals) {\n            ref = colKeyHeaders.children;\n            for (l = 0, len = ref.length; l < len; l++) {\n              child = ref[l];\n              if (child === LOOKER_ROW_TOTAL_KEY) {\n                continue;\n              }\n              for (o = 0, len1 = aggregatorNames.length; o < len1; o++) {\n                name = aggregatorNames[o];\n                th = createElement(\"th\", \"rowTotal\", labels[name]);\n                tr.appendChild(th);\n              }\n            }\n          }\n          if (hasRowTotals && !useLookerRowTotals) {\n            for (q = 0, len2 = aggregatorNames.length; q < len2; q++) {\n              name = aggregatorNames[q];\n              th = createElement(\"th\", \"rowTotal\", labels[name]);\n              tr.appendChild(th);\n            }\n          }\n        } else {\n          th = createElement(\"th\", \"pvtColLabel pvtColTotal\", \"Total*\", {\n            colspan: aggregatorNames.length\n          });\n          tr.appendChild(th);\n        }\n      } else {\n        // No pivots, but we still need to add column headers.\n        for (r = 0, len3 = aggregatorNames.length; r < len3; r++) {\n          name = aggregatorNames[r];\n          th = createElement(\"th\", \"rowTotal\", labels[name]);\n          tr.appendChild(th);\n        }\n      }\n    };\n    lastPivotHeader = null;\n    buildRowHeader = function(\n      tbody,\n      axisHeaders,\n      attrHeaders,\n      h,\n      rowAttrs,\n      colAttrs,\n      node,\n      opts\n    ) {\n      var ah, chKey, firstChild, i, l, len, o, ref, ref1, ref2;\n      ref = h.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        // DF Recurse\n        buildRowHeader(\n          tbody,\n          axisHeaders,\n          attrHeaders,\n          h[chKey],\n          rowAttrs,\n          colAttrs,\n          node,\n          opts\n        );\n      }\n      // Process\n      ah = axisHeaders.ah[h.col];\n      ah.attrHeaders.push(h);\n      h.node = node.counter;\n      h.onClick = collapseRow;\n      if (h.children.length !== 0) {\n        firstChild = h[h.children[0]];\n      }\n      if (lastPivotHeader) {\n        removeClass(lastPivotHeader, \"lastPivot\");\n      }\n      lastPivotHeader = h.th;\n      addClass(\n        h.th,\n        `${classRowShow} pvtRowHeader lastPivot row${h.row} rowcol${h.col} ${classRowExpanded}`\n      );\n      h.th.setAttribute(\"data-rownode\", h.node);\n      if (h.children.length !== 0) {\n        // h.th.colSpan = 2 if h.col is rowAttrs.length-1 and colAttrs.length isnt 0\n        h.th.rowSpan = h.childrenSpan;\n      }\n      h.th.innerHTML = getHeaderText(h, rowAttrs, opts.rowSubtotalDisplay);\n      h.tr = createElement(\"tr\", `row${h.row}`);\n      h.tr.appendChild(h.th);\n      if (h.children.length === 0) {\n        tbody.appendChild(h.tr);\n      } else {\n        tbody.insertBefore(h.tr, firstChild.tr);\n      }\n      if (\n        h.children.length !== 0 &&\n        h.col < opts.rowSubtotalDisplay.disableFrom\n      ) {\n        ++ah.expandedCount;\n        ++ah.expandables;\n        if (!opts.rowSubtotalDisplay.disableExpandCollapse) {\n          h.th.onclick = function(event) {\n            event = event || window.event;\n            return h.onClick(axisHeaders, h, opts.rowSubtotalDisplay);\n          };\n        }\n        for (\n          i = o = 0, ref1 = rowAttrs.length - h.col - 1;\n          0 <= ref1 ? o < ref1 : o > ref1;\n          i = 0 <= ref1 ? ++o : --o\n        ) {\n          h.sTh = createElement(\n            \"th\",\n            `pvtRowLabelFiller row${h.row} rowcol${h.col} ${classRowExpanded} ${classRowShow}`\n          );\n          if (opts.rowSubtotalDisplay.hideOnExpand && h.col > showSubtotalFromIndex) {\n            replaceClass(h.sTh, classRowShow, classRowHide);\n          }\n          h.sTh.setAttribute(\"data-rownode\", h.node);\n          //h.sTh.colSpan = rowAttrs.length-h.col-1\n          if (opts.rowSubtotalDisplay.displayOnTop) {\n            h.tr.appendChild(h.sTh);\n          } else {\n            h.th.rowSpan += 1; // if not opts.rowSubtotalDisplay.hideOnExpand\n            h.sTr = createElement(\"tr\", `row${h.row}`);\n            h.sTr.appendChild(h.sTh);\n            tbody.appendChild(h.sTr);\n          }\n        }\n      }\n      if (h.children.length !== 0) {\n        h.th.rowSpan++;\n      }\n      if ((ref2 = h.parent) != null) {\n        ref2.childrenSpan += h.th.rowSpan;\n      }\n      h.clickStatus = clickStatusExpanded;\n      attrHeaders.push(h);\n      return node.counter++;\n    };\n    getTableEventHandlers = function(\n      value,\n      rowKey,\n      colKey,\n      rowAttrs,\n      colAttrs,\n      opts\n    ) {\n      var attr, event, eventHandlers, filters, handler, i, ref, ref1;\n      if (!((ref = opts.table) != null ? ref.eventHandlers : void 0)) {\n        return;\n      }\n      eventHandlers = {};\n      ref1 = opts.table.eventHandlers;\n      for (event in ref1) {\n        if (!hasProp.call(ref1, event)) continue;\n        handler = ref1[event];\n        filters = {};\n        for (i in colAttrs) {\n          if (!hasProp.call(colAttrs, i)) continue;\n          attr = colAttrs[i];\n          if (colKey[i] != null) {\n            filters[attr] = colKey[i];\n          }\n        }\n        for (i in rowAttrs) {\n          if (!hasProp.call(rowAttrs, i)) continue;\n          attr = rowAttrs[i];\n          if (rowKey[i] != null) {\n            filters[attr] = rowKey[i];\n          }\n        }\n        eventHandlers[event] = function(e) {\n          return handler(e, value, filters, pivotData);\n        };\n      }\n      return eventHandlers;\n    };\n    buildValues = function(\n      tbody,\n      colAttrHeaders,\n      rowAttrHeaders,\n      rowAttrs,\n      colAttrs,\n      opts\n    ) {\n      var aggregator,\n        ch,\n        cls,\n        l,\n        len,\n        len1,\n        len2,\n        len3,\n        name,\n        o,\n        q,\n        r,\n        rCls,\n        ref,\n        rh,\n        td,\n        totalAggregator,\n        tr,\n        val;\n      for (l = 0, len = rowAttrHeaders.length; l < len; l++) {\n        rh = rowAttrHeaders[l];\n        if (\n          !(\n            rh.col === rowAttrs.length - 1 ||\n            (rh.children.length !== 0 &&\n              rh.col < opts.rowSubtotalDisplay.disableFrom)\n          )\n        ) {\n          continue;\n        }\n        rCls = `pvtVal row${rh.row} rowcol${rh.col} ${classRowExpanded}`;\n        if (rh.children.length > 0) {\n          rCls += \" pvtRowSubtotal\";\n          rCls += opts.rowSubtotalDisplay.hideOnExpand && rh.col > showSubtotalFromIndex\n            ? ` ${classRowHide}`\n            : `  ${classRowShow}`;\n        } else {\n          rCls += ` ${classRowShow}`;\n        }\n        tr = rh.sTr ? rh.sTr : rh.tr;\n        for (o = 0, len1 = colAttrHeaders.length; o < len1; o++) {\n          ch = colAttrHeaders[o];\n          if (\n            ch.col === colAttrs.length - 1 ||\n            (ch.children.length !== 0 &&\n              ch.col < opts.colSubtotalDisplay.disableFrom)\n          ) {\n            for (q = 0, len2 = aggregatorNames.length; q < len2; q++) {\n              name = aggregatorNames[q];\n              let reference =\n                tree[rh.flatKey][ch.flatKey] &&\n                tree[rh.flatKey][ch.flatKey][name];\n              aggregator = reference\n                ? reference\n                : {\n                    value: function() {\n                      return null;\n                    },\n                    format: function() {\n                      return \"\";\n                    }\n                  };\n              val = aggregator.value();\n              cls = ` ${rCls} col${ch.row} colcol${ch.col} ${classColExpanded}`;\n              if (ch.children.length > 0) {\n                cls += \" pvtColSubtotal\";\n                cls += opts.colSubtotalDisplay.hideOnExpand\n                  ? ` ${classColHide}`\n                  : ` ${classColShow}`;\n              } else {\n                cls += ` ${classColShow}`;\n              }\n              td = createElement(\n                \"td\",\n                cls,\n                aggregator.format(val),\n                {\n                  \"data-value\": val,\n                  \"data-rownode\": rh.node,\n                  \"data-colnode\": ch.node\n                },\n                getTableEventHandlers(\n                  val,\n                  rh.key,\n                  ch.key,\n                  rowAttrs,\n                  colAttrs,\n                  opts\n                )\n              );\n              tr.appendChild(td);\n            }\n          }\n        }\n        // buildRowTotal\n        if (hasRowTotals && !useLookerRowTotals) {\n          for (r = 0, len3 = aggregatorNames.length; r < len3; r++) {\n            name = aggregatorNames[r];\n            totalAggregator = rowTotals[rh.flatKey][name];\n            val = totalAggregator.value();\n            td = createElement(\n              \"td\",\n              `pvtTotal rowTotal ${rCls}`,\n              totalAggregator.format(val),\n              {\n                \"data-value\": val,\n                \"data-row\": `row${rh.row}`,\n                \"data-rowcol\": `col${rh.col}`,\n                \"data-rownode\": rh.node\n              }\n            );\n            getTableEventHandlers(val, rh.key, [], rowAttrs, colAttrs, opts);\n            tr.appendChild(td);\n          }\n        }\n      }\n    };\n    buildColTotalsHeader = function(rowAttrs, colAttrs) {\n      var colspan, th, tr;\n      tr = createElement(\"tr\", \"pvtRowTotal\");\n      colspan = rowAttrs.length;\n      th = createElement(\n        \"th\",\n        \"pvtTotalLabel colTotal\",\n        opts.localeStrings.totals,\n        {\n          colspan: colspan\n        }\n      );\n      tr.appendChild(th);\n      return tr;\n    };\n    buildColTotals = function(tr, attrHeaders, rowAttrs, colAttrs, opts) {\n      var clsNames, h, i, l, len, len1, name, o, td, totalAggregator, val;\n      for (l = 0, len = attrHeaders.length; l < len; l++) {\n        h = attrHeaders[l];\n        if (\n          !(\n            h.col === colAttrs.length - 1 ||\n            (h.children.length !== 0 &&\n              h.col < opts.colSubtotalDisplay.disableFrom)\n          )\n        ) {\n          continue;\n        }\n        clsNames = `pvtVal pvtTotal colTotal ${classColExpanded} col${h.row} colcol${h.col}`;\n        if (h.children.length !== 0) {\n          clsNames += \" pvtColSubtotal\";\n          clsNames += opts.colSubtotalDisplay.hideOnExpand\n            ? ` ${classColHide}`\n            : ` ${classColShow}`;\n        } else {\n          clsNames += ` ${classColShow}`;\n        }\n        for (i = o = 0, len1 = aggregatorNames.length; o < len1; i = ++o) {\n          name = aggregatorNames[i];\n          totalAggregator = colTotals[h.flatKey][aggregatorNames[i]];\n          val = totalAggregator.value();\n          td = createElement(\n            \"td\",\n            clsNames,\n            totalAggregator.format(val),\n            {\n              \"data-value\": val,\n              \"data-for\": `col${h.col}`,\n              \"data-colnode\": `${h.node}`\n            },\n            getTableEventHandlers(val, [], h.key, rowAttrs, colAttrs, opts)\n          );\n          tr.appendChild(td);\n        }\n      }\n    };\n    buildGrandTotal = function(tbody, tr, rowAttrs, colAttrs, opts) {\n      var l, len, name, results, td, totalAggregator, val;\n      results = [];\n      for (l = 0, len = aggregatorNames.length; l < len; l++) {\n        name = aggregatorNames[l];\n        totalAggregator = allTotal[name];\n        val = totalAggregator.value();\n        td = createElement(\n          \"td\",\n          \"pvtGrandTotal\",\n          totalAggregator.format(val),\n          {\n            \"data-value\": val\n          },\n          getTableEventHandlers(val, [], [], rowAttrs, colAttrs, opts)\n        );\n        results.push(tr.appendChild(td));\n      }\n      return results;\n    };\n    collapseAxisHeaders = function(axisHeaders, col, opts) {\n      var ah, collapsible, i, l, ref, ref1, results;\n      collapsible = Math.min(axisHeaders.ah.length - 2, opts.disableFrom - 1);\n      if (col > collapsible) {\n        return;\n      }\n      results = [];\n      for (\n        i = l = ref = col, ref1 = collapsible;\n        ref <= ref1 ? l <= ref1 : l >= ref1;\n        i = ref <= ref1 ? ++l : --l\n      ) {\n        ah = axisHeaders.ah[i];\n        replaceClass(ah.th, classExpanded, classCollapsed);\n        ah.th.innerHTML = parseLabel([` ${arrowCollapsed} `, ah.text]);\n        ah.clickStatus = clickStatusCollapsed;\n        results.push((ah.onClick = expandAxis));\n      }\n      return results;\n    };\n    adjustAxisHeader = function(axisHeaders, col, opts) {\n      var ah;\n      ah = axisHeaders.ah[col];\n      if (ah.expandedCount === 0) {\n        return collapseAxisHeaders(axisHeaders, col, opts);\n      } else if (ah.expandedCount === ah.expandables) {\n        replaceClass(ah.th, classCollapsed, classExpanded);\n        ah.th.innerHTML = parseLabel([` ${arrowExpanded} `, ah.text]);\n        ah.clickStatus = clickStatusExpanded;\n        return (ah.onClick = collapseAxis);\n      }\n    };\n    hideChildCol = function(ch) {\n      return $(ch.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${ch.node}\\\"], th[data-colnode=\\\"${ch.node}\\\"]`\n        )\n        .removeClass(classColShow)\n        .addClass(classColHide);\n    };\n    collapseHiddenColSubtotal = function(h, opts) {\n      $(h.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`\n        )\n        .removeClass(classColExpanded)\n        .addClass(classColCollapsed);\n      if (h.children.length !== 0) {\n        h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n      }\n      return (h.th.colSpan = 1);\n    };\n    collapseShowColSubtotal = function(h, opts) {\n      $(h.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`\n        )\n        .removeClass(classColExpanded)\n        .addClass(classColCollapsed)\n        .removeClass(classColHide)\n        .addClass(classColShow);\n      if (h.children.length !== 0) {\n        h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n      }\n      return (h.th.colSpan = 1);\n    };\n    collapseChildCol = function(ch, h) {\n      var chKey, l, len, ref;\n      ref = ch.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        if (hasClass(ch[chKey].th, classColShow)) {\n          collapseChildCol(ch[chKey], h);\n        }\n      }\n      return hideChildCol(ch);\n    };\n    collapseCol = function(axisHeaders, h, opts) {\n      var chKey, colSpan, l, len, p, ref;\n      colSpan = h.th.colSpan - 1;\n      ref = h.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        if (hasClass(h[chKey].th, classColShow)) {\n          collapseChildCol(h[chKey], h);\n        }\n      }\n      if (h.col < opts.disableFrom) {\n        if (hasClass(h.th, classColHide)) {\n          collapseHiddenColSubtotal(h, opts);\n        } else {\n          collapseShowColSubtotal(h, opts);\n        }\n      }\n      p = h.parent;\n      while (p) {\n        p.th.colSpan -= colSpan;\n        p = p.parent;\n      }\n      h.clickStatus = clickStatusCollapsed;\n      h.onClick = expandCol;\n      axisHeaders.ah[h.col].expandedCount--;\n      return adjustAxisHeader(axisHeaders, h.col, opts);\n    };\n    showChildCol = function(ch) {\n      return $(ch.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${ch.node}\\\"], th[data-colnode=\\\"${ch.node}\\\"]`\n        )\n        .removeClass(classColHide)\n        .addClass(classColShow);\n    };\n    expandHideColSubtotal = function(h) {\n      $(h.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`\n        )\n        .removeClass(`${classColCollapsed} ${classColShow}`)\n        .addClass(`${classColExpanded} ${classColHide}`);\n      replaceClass(h.th, classColHide, classColShow);\n      return (h.th.innerHTML = ` ${arrowExpanded} ${h.text}`);\n    };\n    expandShowColSubtotal = function(h) {\n      $(h.th)\n        .closest(\"table.pvtTable\")\n        .find(\n          `tbody tr td[data-colnode=\\\"${h.node}\\\"], th[data-colnode=\\\"${h.node}\\\"]`\n        )\n        .removeClass(`${classColCollapsed} ${classColHide}`)\n        .addClass(`${classColExpanded} ${classColShow}`);\n      h.th.colSpan++;\n      return (h.th.innerHTML = ` ${arrowExpanded} ${h.text}`);\n    };\n    expandChildCol = function(ch, opts) {\n      var chKey, l, len, ref, results;\n      if (\n        ch.children.length !== 0 &&\n        opts.hideOnExpand &&\n        ch.clickStatus === clickStatusExpanded\n      ) {\n        replaceClass(ch.th, classColHide, classColShow);\n      } else {\n        showChildCol(ch);\n      }\n      if (\n        ch.sTh &&\n        ch.clickStatus === clickStatusExpanded &&\n        opts.hideOnExpand\n      ) {\n        replaceClass(ch.sTh, classColShow, classColHide);\n      }\n      if (\n        ch.clickStatus === clickStatusExpanded ||\n        ch.col >= opts.disableFrom\n      ) {\n        ref = ch.children;\n        results = [];\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          results.push(expandChildCol(ch[chKey], opts));\n        }\n        return results;\n      }\n    };\n    expandCol = function(axisHeaders, h, opts) {\n      var ch, chKey, colSpan, l, len, p, ref;\n      if (h.clickStatus === clickStatusExpanded) {\n        adjustAxisHeader(axisHeaders, h.col, opts);\n        return;\n      }\n      colSpan = 0;\n      ref = h.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        ch = h[chKey];\n        expandChildCol(ch, opts);\n        colSpan += ch.th.colSpan;\n      }\n      h.th.colSpan = colSpan;\n      if (h.col < opts.disableFrom) {\n        if (opts.hideOnExpand  && h.col > showSubtotalFromIndex) {\n          expandHideColSubtotal(h);\n          --colSpan;\n        } else {\n          expandShowColSubtotal(h);\n        }\n      }\n      p = h.parent;\n      while (p) {\n        p.th.colSpan += colSpan;\n        p = p.parent;\n      }\n      h.clickStatus = clickStatusExpanded;\n      h.onClick = collapseCol;\n      axisHeaders.ah[h.col].expandedCount++;\n      return adjustAxisHeader(axisHeaders, h.col, opts);\n    };\n    hideChildRow = function(ch, opts) {\n      var cell, l, len, len1, o, ref, ref1, results;\n      ref = ch.tr.querySelectorAll(\"th, td\");\n      for (l = 0, len = ref.length; l < len; l++) {\n        cell = ref[l];\n        replaceClass(cell, classRowShow, classRowHide);\n      }\n      if (ch.sTr) {\n        ref1 = ch.sTr.querySelectorAll(\"th, td\");\n        results = [];\n        for (o = 0, len1 = ref1.length; o < len1; o++) {\n          cell = ref1[o];\n          results.push(replaceClass(cell, classRowShow, classRowHide));\n        }\n        return results;\n      }\n    };\n    collapseShowRowSubtotal = function(h, opts) {\n      var cell, l, len, len1, o, ref, ref1, results;\n      if (childNumberToCollapse && h.descendants === childNumberToCollapse) {\n        h.th.innerHTML = ` ${h.text}`;\n      } else {\n        h.th.innerHTML = ` ${arrowCollapsed} ${h.text}`;\n      }\n      ref = h.tr.querySelectorAll(\"th, td\");\n      for (l = 0, len = ref.length; l < len; l++) {\n        cell = ref[l];\n        removeClass(cell, `${classRowExpanded} ${classRowHide}`);\n        addClass(cell, `${classRowCollapsed} ${classRowShow}`);\n      }\n      if (h.sTr) {\n        ref1 = h.sTr.querySelectorAll(\"th, td\");\n        results = [];\n        for (o = 0, len1 = ref1.length; o < len1; o++) {\n          cell = ref1[o];\n          removeClass(cell, `${classRowExpanded} ${classRowHide}`);\n          results.push(addClass(cell, `${classRowCollapsed} ${classRowShow}`));\n        }\n        return results;\n      }\n    };\n    collapseChildRow = function(ch, h, opts) {\n      var chKey, l, len, ref;\n      ref = ch.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        collapseChildRow(ch[chKey], h, opts);\n      }\n      if (childNumberToCollapse && childNumberToCollapse === h.descendants)  {\n        if (ch.parent === h) {\n          let newCell = ch.parent.tr.cells[1];\n          newCell.innerHTML = ch.text;\n        } else {\n          let newCell = h.tr.cells[ch.col - h.col];\n          newCell.innerHTML = ch.text;\n        }\n      }\n      return hideChildRow(ch, opts);\n    };\n    collapseRow = function(axisHeaders, h, opts) {\n      var chKey, l, len, ref;\n      ref = h.children;\n      for (l = 0, len = ref.length; l < len; l++) {\n        chKey = ref[l];\n        collapseChildRow(h[chKey], h, opts);\n      }\n      collapseShowRowSubtotal(h, opts);\n      h.clickStatus = clickStatusCollapsed;\n      h.onClick = expandRow;\n      axisHeaders.ah[h.col].expandedCount--;\n      return adjustAxisHeader(axisHeaders, h.col, opts);\n    };\n    showChildRow = function(ch, opts) {\n      var cell, l, len, len1, o, ref, ref1, results;\n      ref = ch.tr.querySelectorAll(\"th, td\");\n      for (l = 0, len = ref.length; l < len; l++) {\n        cell = ref[l];\n        replaceClass(cell, classRowHide, classRowShow);\n      }\n      if (ch.sTr) {\n        ref1 = ch.sTr.querySelectorAll(\"th, td\");\n        results = [];\n        for (o = 0, len1 = ref1.length; o < len1; o++) {\n          cell = ref1[o];\n          results.push(replaceClass(cell, classRowHide, classRowShow));\n        }\n        return results;\n      }\n    };\n    expandShowRowSubtotal = function(h, opts) {\n      var cell, l, len, len1, o, ref, ref1, results;\n      h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n      ref = h.tr.querySelectorAll(\"th, td\");\n      for (l = 0, len = ref.length; l < len; l++) {\n        cell = ref[l];\n        removeClass(cell, `${classRowCollapsed} ${classRowHide}`);\n        addClass(cell, `${classRowExpanded} ${classRowShow}`);\n      }\n      if (h.sTr) {\n        ref1 = h.sTr.querySelectorAll(\"th, td\");\n        results = [];\n        for (o = 0, len1 = ref1.length; o < len1; o++) {\n          cell = ref1[o];\n          removeClass(cell, `${classRowCollapsed} ${classRowHide}`);\n          results.push(addClass(cell, `${classRowExpanded} ${classRowShow}`));\n        }\n        return results;\n      }\n    };\n    expandHideRowSubtotal = function(h, opts) {\n      var cell, l, len, len1, o, ref, ref1, results;\n      h.th.innerHTML = ` ${arrowExpanded} ${h.text}`;\n      ref = h.tr.querySelectorAll(\"th, td\");\n      for (l = 0, len = ref.length; l < len; l++) {\n        cell = ref[l];\n        removeClass(cell, `${classRowCollapsed} ${classRowShow}`);\n        addClass(cell, `${classRowExpanded} ${classRowHide}`);\n      }\n      removeClass(h.th, `${classRowCollapsed} ${classRowHide}`);\n      addClass(cell, `${classRowExpanded} ${classRowShow}`);\n      if (h.sTr) {\n        ref1 = h.sTr.querySelectorAll(\"th, td\");\n        results = [];\n        for (o = 0, len1 = ref1.length; o < len1; o++) {\n          cell = ref1[o];\n          removeClass(cell, `${classRowCollapsed} ${classRowShow}`);\n          results.push(addClass(cell, `${classRowExpanded} ${classRowHide}`));\n        }\n        return results;\n      }\n    };\n    expandChildRow = function(ch, opts) {\n      var chKey, l, len, ref, results;\n      if (\n        childNumberToCollapse &&\n        childNumberToCollapse === ch.parent.descendants\n      ) {\n        let cellsToclear = ch.parent.tr.getElementsByClassName(\n          \"pvtRowLabelFiller\"\n        );\n        for (let cell of cellsToclear) {\n          cell.innerHTML = \"\";\n        }\n      }\n      if (\n        ch.children.length !== 0 &&\n        opts.hideOnExpand &&\n        ch.clickStatus === clickStatusExpanded\n      ) {\n        replaceClass(ch.th, classRowHide, classRowShow);\n      } else {\n        showChildRow(ch, opts);\n      }\n      if (\n        ch.sTh &&\n        ch.clickStatus === clickStatusExpanded &&\n        opts.hideOnExpand\n      ) {\n        replaceClass(ch.sTh, classRowShow, classRowHide);\n      }\n      if (\n        ch.clickStatus === clickStatusExpanded ||\n        ch.col >= opts.disableFrom\n      ) {\n        ref = ch.children;\n        results = [];\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          results.push(expandChildRow(ch[chKey], opts));\n        }\n        return results;\n      }\n    };\n    expandRow = function(axisHeaders, h, opts) {\n      var ch, chKey, l, len, ref;\n      if (h.clickStatus === clickStatusExpanded) {\n        adjustAxisHeader(axisHeaders, h.col, opts);\n        return;\n      }\n      ref = h.children;\n      if(h.descendants > childNumberToCollapse) {\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          ch = h[chKey];\n          expandChildRow(ch, opts);\n        }\n        if (opts.hideOnExpand && h.col > showSubtotalFromIndex) {\n          expandHideRowSubtotal(h, opts);\n        } else {\n          expandShowRowSubtotal(h, opts);\n        }\n      }\n      if (ref.length !== 0) {\n        h.clickStatus = clickStatusExpanded;\n        h.onClick = collapseRow;\n      }\n      axisHeaders.ah[h.col].expandedCount++;\n      return adjustAxisHeader(axisHeaders, h.col, opts);\n    };\n    collapseAxis = function(axisHeaders, col, attrs, opts) {\n      var collapsible, h, i, l, ref, ref1, results;\n      collapsible = Math.min(attrs.length - 2, opts.disableFrom - 1);\n      if (col > collapsible) {\n        return;\n      }\n      results = [];\n      for (i = l = ref = collapsible, ref1 = col; l >= ref1; i = l += -1) {\n        results.push(\n          (function() {\n            var len, o, ref2, results1;\n            ref2 = axisHeaders.ah[i].attrHeaders;\n            results1 = [];\n            for (o = 0, len = ref2.length; o < len; o++) {\n              h = ref2[o];\n              if (\n                h.clickStatus === clickStatusExpanded &&\n                h.children.length !== 0\n              ) {\n                results1.push(\n                  axisHeaders.collapseAttrHeader(axisHeaders, h, opts)\n                );\n              }\n            }\n            return results1;\n          })()\n        );\n      }\n      return results;\n    };\n    collapseChildRows = function(axisHeaders, col, attrs, opts) {\n      var collapsible, h, i, l, ref, ref1, results;\n      collapsible = Math.min(attrs.length - 2, opts.disableFrom - 1);\n      results = [];\n      for (i = l = ref = collapsible, ref1 = col; l >= ref1; i = l += -1) {\n        results.push(\n          (function() {\n            var len, o, ref2, results1;\n            ref2 = axisHeaders.ah[i].attrHeaders;\n            results1 = [];\n            for (o = 0, len = ref2.length; o < len; o++) {\n              h = ref2[o];\n              if (\n                h.clickStatus === clickStatusExpanded &&\n                h.descendants === childNumberToCollapse\n              ) {\n                results1.push(\n                  axisHeaders.collapseAttrHeader(axisHeaders, h, opts)\n                );\n              }\n            }\n            return results1;\n          })()\n        );\n      }\n      return results;\n    };\n    expandAxis = function(axisHeaders, col, attrs, opts) {\n      var ah, h, i, l, ref, results;\n      ah = axisHeaders.ah[col];\n      results = [];\n      for (\n        i = l = 0, ref = col;\n        0 <= ref ? l <= ref : l >= ref;\n        i = 0 <= ref ? ++l : --l\n      ) {\n        results.push(\n          (function() {\n            var len, o, ref1, results1;\n            ref1 = axisHeaders.ah[i].attrHeaders;\n            results1 = [];\n            for (o = 0, len = ref1.length; o < len; o++) {\n              h = ref1[o];\n              results1.push(axisHeaders.expandAttrHeader(axisHeaders, h, opts));\n            }\n            return results1;\n          })()\n        );\n      }\n      return results;\n    };\n    // when h.clickStatus is clickStatusCollapsed and h.children.length isnt 0 for i in [0..col]\n    main = function(rowAttrs, rowKeys, colAttrs, colKeys) {\n      var ah,\n        chKey,\n        colAttrHeaders,\n        colAxisHeaders,\n        colKeyHeaders,\n        index,\n        l,\n        len,\n        len1,\n        len2,\n        node,\n        o,\n        q,\n        ref,\n        ref1,\n        ref2,\n        result,\n        rowAttrHeaders,\n        rowAxisHeaders,\n        rowKeyHeaders,\n        tableClasses,\n        tbody,\n        thead,\n        tr;\n      rowAttrHeaders = [];\n      colAttrHeaders = [];\n      if (colAttrs.length !== 0 && colKeys.length !== 0) {\n        colKeyHeaders = processKeys(colKeys, \"pvtColLabel\");\n      }\n      if (rowAttrs.length !== 0 && rowKeys.length !== 0) {\n        rowKeyHeaders = processKeys(rowKeys, \"pvtRowLabel\");\n      }\n      if (colKeyHeaders && !useLookerRowTotals) {\n        delete colKeyHeaders[LOOKER_ROW_TOTAL_KEY];\n        colKeyHeaders.children = colKeyHeaders.children.filter(function(k) {\n          return k !== LOOKER_ROW_TOTAL_KEY;\n        });\n      }\n      tableClasses = \"pvtTable\";\n      if (hasRowTotals) {\n        tableClasses += \" pvtHasRowTotals\";\n      }\n      if (hasColTotals) {\n        tableClasses += \" pvtHasColTotals\";\n      }\n      result = createElement(\"table\", tableClasses, null, {\n        style: \"display: none;\"\n      });\n      thead = createElement(\"thead\");\n      result.appendChild(thead);\n      if (colAttrs.length !== 0) {\n        colAxisHeaders = buildColAxisHeaders(thead, rowAttrs, colAttrs, opts);\n        node = {\n          counter: 0\n        };\n        ref = colKeyHeaders.children;\n        for (l = 0, len = ref.length; l < len; l++) {\n          chKey = ref[l];\n          buildColHeader(\n            colAxisHeaders,\n            colAttrHeaders,\n            colKeyHeaders[chKey],\n            rowAttrs,\n            colAttrs,\n            node,\n            opts\n          );\n        }\n        if (hasRowTotals && !useLookerRowTotals) {\n          ref1 = colAxisHeaders.ah;\n          for (index = o = 0, len1 = ref1.length; o < len1; index = ++o) {\n            ah = ref1[index];\n            if (index === colAxisHeaders.ah.length - 1) {\n              buildRowTotalsHeader(ah.tr, null, rowAttrs, colAttrs);\n            } else {\n              ah.tr.appendChild(\n                createElement(\"th\", \"pvtColTotalFiller\", null, {\n                  colspan: colAttrs.length\n                })\n              );\n            }\n          }\n        }\n      }\n      tbody = createElement(\"tbody\");\n      result.appendChild(tbody);\n      if (rowAttrs.length !== 0) {\n        rowAxisHeaders = buildRowAxisHeaders(thead, rowAttrs, colAttrs, opts);\n        buildRowTotalsHeader(\n          rowAxisHeaders.tr,\n          colKeyHeaders,\n          rowAttrs,\n          colAttrs\n        );\n        node = {\n          counter: 0\n        };\n        ref2 = rowKeyHeaders.children;\n        for (q = 0, len2 = ref2.length; q < len2; q++) {\n          chKey = ref2[q];\n          buildRowHeader(\n            tbody,\n            rowAxisHeaders,\n            rowAttrHeaders,\n            rowKeyHeaders[chKey],\n            rowAttrs,\n            colAttrs,\n            node,\n            opts\n          );\n        }\n      }\n      buildValues(\n        tbody,\n        colAttrHeaders,\n        rowAttrHeaders,\n        rowAttrs,\n        colAttrs,\n        opts\n      );\n      if (hasColTotals) {\n        tr = buildColTotalsHeader(rowAttrs, colAttrs);\n        if (colAttrs.length > 0) {\n          buildColTotals(tr, colAttrHeaders, rowAttrs, colAttrs, opts);\n        }\n        if (hasRowTotals && !useLookerRowTotals) {\n          buildGrandTotal(tbody, tr, rowAttrs, colAttrs, opts);\n        }\n        tbody.appendChild(tr);\n      }\n      collapseAxis(\n        colAxisHeaders,\n        opts.colSubtotalDisplay.collapseAt,\n        colAttrs,\n        opts.colSubtotalDisplay\n      );\n      collapseAxis(\n        rowAxisHeaders,\n        opts.rowSubtotalDisplay.collapseAt,\n        rowAttrs,\n        opts.rowSubtotalDisplay\n      );\n      collapseChildRows(rowAxisHeaders, 0, rowAttrs, opts.rowSubtotalDisplay);\n      result.setAttribute(\"data-numrows\", rowKeys.length);\n      result.setAttribute(\"data-numcols\", colKeys.length);\n      result.style.display = \"\";\n      return result;\n    };\n    return main(rowAttrs, rowKeys, colAttrs, colKeys);\n  };\n  $.pivotUtilities.subtotal_renderers = {\n    \"Table With Subtotal\": function(pvtData, opts) {\n      return SubtotalRenderer(pvtData, opts);\n    },\n    \"Table With Subtotal Bar Chart\": function(pvtData, opts) {\n      return $(SubtotalRenderer(pvtData, opts)).barchart();\n    },\n    \"Table With Subtotal Heatmap\": function(pvtData, opts) {\n      return $(SubtotalRenderer(pvtData, opts)).heatmap(\"heatmap\", opts);\n    },\n    \"Table With Subtotal Row Heatmap\": function(pvtData, opts) {\n      return $(SubtotalRenderer(pvtData, opts)).heatmap(\"rowheatmap\", opts);\n    },\n    \"Table With Subtotal Col Heatmap\": function(pvtData, opts) {\n      return $(SubtotalRenderer(pvtData, opts)).heatmap(\"colheatmap\", opts);\n    }\n  };\n\n  // Aggregators\n\n  usFmtPct = $.pivotUtilities.numberFormat({\n    digitsAfterDecimal: 1,\n    scaler: 100,\n    suffix: \"%\"\n  });\n  aggregatorTemplates = $.pivotUtilities.aggregatorTemplates;\n  subtotalAggregatorTemplates = {\n    fractionOf: function(wrapped, type = \"row\", formatter = usFmtPct) {\n      return function(...x) {\n        return function(data, rowKey, colKey) {\n          if (typeof rowKey === \"undefined\") {\n            rowKey = [];\n          }\n          if (typeof colKey === \"undefined\") {\n            colKey = [];\n          }\n          return {\n            selector: {\n              row: [rowKey.slice(0, -1), []],\n              col: [[], colKey.slice(0, -1)]\n            }[type],\n            inner: wrapped(...x)(data, rowKey, colKey),\n            push: function(record) {\n              return this.inner.push(record);\n            },\n            format: formatter,\n            value: function() {\n              return (\n                this.inner.value() /\n                data.getAggregator(...this.selector).inner.value()\n              );\n            },\n            numInputs: wrapped(...x)().numInputs\n          };\n        };\n      };\n    }\n  };\n  $.pivotUtilities.subtotalAggregatorTemplates = subtotalAggregatorTemplates;\n  return ($.pivotUtilities.subtotal_aggregators = (function(tpl, sTpl) {\n    return {\n      \"Sum As Fraction Of Parent Row\": sTpl.fractionOf(\n        tpl.sum(),\n        \"row\",\n        usFmtPct\n      ),\n      \"Sum As Fraction Of Parent Column\": sTpl.fractionOf(\n        tpl.sum(),\n        \"col\",\n        usFmtPct\n      ),\n      \"Count As Fraction Of Parent Row\": sTpl.fractionOf(\n        tpl.count(),\n        \"row\",\n        usFmtPct\n      ),\n      \"Count As Fraction Of Parent Column\": sTpl.fractionOf(\n        tpl.count(),\n        \"col\",\n        usFmtPct\n      )\n    };\n  })(aggregatorTemplates, subtotalAggregatorTemplates));\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });